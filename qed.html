        <html>
        <head>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
          <title>QED Report</title>
          <style>
            body{width:800px; margin:0 auto;}
            pre{font-family: courier,monospace;}
            .pass{color: #020;}
            .pass pre{color: green;}
            .fail{color: #200; background: pink;}
            .fail pre{color: green;}
            .error{color: #200; background: pink;}
            .error pre{color: red;}
          </style>
        </head>
        <body>
        <h2>qed/01_demos.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Demonstrations">Demonstrations</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Steps">Steps</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>QED demos are light-weight specification documents, highly suitable to
interface-driven design. The documents are divided up into steps separated
by blank lines. Steps that are flush to the  left margin are always
explanatory comments. Indented steps are either executable code or plain
text samples.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Each step is executed in order of appearance within a rescue wrapper that
captures any failures or errors. If neither a failure or error occur then
the step gets a “pass”.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>For example, the following passes.</p>


          <pre>    (2 + 2).assert == 4

</pre>
        </div>
        <div class="test pass">
          
<p>While the following would “fail”, as indicated by the raising of  an
Assertion error.</p>


          <pre>    expect Assertion do
      (2 + 2).assert == 5
    end

</pre>
        </div>
        <div class="test pass">
          
<p>And this would have raised a NameError.</p>


          <pre>    expect NameError do
      nobody_knows_method
    end

</pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Defining+Custom+Assertions">Defining Custom Assertions</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>The context in which the QED code is run is a self-extended module, thus
reusable macros can be created simply by defining a method.</p>


          <pre>    def assert_integer(x)
      x.assert.is_a? Integer
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Now lets try out our new macro definition.</p>


          <pre>    assert_integer(4)

</pre>
        </div>
        <div class="test pass">
          
<p>Let’s prove that it can also fail.</p>


          <pre>    expect Assertion do
      assert_integer("IV")
    end

</pre>
        </div>
        <h2>qed/02_advice.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Advice">Advice</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Advice are event-based procedures that augment demonstrations. They are
used to keep demonstrations clean of extraneous, repetitive and merely
adminstrative code that the reader does not need to see over and over.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Typically you will want to put advice definitions in applique files, rather
then place them directly in the demonstration document, but you can do so,
as you will see in this document.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Before+and+After">Before and After</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>QED supports <strong>before</strong> and <strong>after</strong> clauses in
a specification through the use of Before and After code blocks. These
blocks are executed at the beginning and at the end of each indicated step.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>We use a <strong>before</strong> clause if we want to setup some code at
the start of each code step.</p>


          <pre>    a, z = nil, nil

    Before do
      a = "BEFORE"
    end

</pre>
        </div>
        <div class="test pass">
          
<p>And an <strong>after</strong> clause to teardown objects after a code step.</p>


          <pre>    After do
      z = "AFTER"
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Notice we assigned <code>a</code> and <code>z</code> before the block. This
was to ensure their visibility in the scope later. Now, lets verify that
the <strong>before</strong> and <strong>after</strong> clauses work.</p>


          <pre>    a.assert == "BEFORE"

    a = "A"
    z = "Z"

</pre>
        </div>
        <div class="test pass">
          
<p>And now.</p>


          <pre>    z.assert == "AFTER"

</pre>
        </div>
        <div class="test pass">
          
<p>There can be more than one before and after clause at a time. If we define
a new <strong>before</strong> or <strong>after</strong> clause later in the
document, it will be appended to the current list of clauses in use.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>As a demonstration of this,</p>


          <pre>    b = nil

    Before do
      b = "BEFORE AGAIN"
    end

</pre>
        </div>
        <div class="test pass">
          
<p>We will see it is the case.</p>


          <pre>    b.assert == "BEFORE AGAIN"

</pre>
        </div>
        <div class="test pass">
          
<p>Only use <strong>before</strong> and <strong>after</strong> clauses when
necessary –specifications are generally more readable without them. Indeed,
some developers make a policy of avoiding them altogether. YMMV.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Caveats+of+Before+and+After">Caveats of Before and After</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Instead of using Before and After clauses, it is wiser to define a reusable
setup method. For example, in the helper if we define a method such as
#prepare_example.</p>


          <pre>  def prepare_example
    "Hello, World!"
  end

</pre>
        </div>
        <div class="test pass">
          
<p>Then we can reuse it in later code blocks.</p>


          <pre>  example = prepare_example
  example.assert == "Hello, World!"

</pre>
        </div>
        <div class="test pass">
          
<p>The advantage to this is that it gives the reader an indication of what is
going on behind the scenes, rather the having an object just magically
appear.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Event+Targets">Event Targets</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>There is a small set of advice targets that do not come before or after,
rather they occur <strong>upon</strong> a particular event. These include
<code>:load</code> and <code>:unload</code> for when a new helper is
loaded; <code>:pass</code>, <code>:fail</code> and <code>:error</code> for
when a code block passes, fails or raises an error; and <code>:head</code>,
<code>:desc:</code>, <code>:code</code> and <code>:data:</code> which
targets the immediate processing of a text block and code excecution.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>These event targets can be advised by calling the <code>When</code> method
with the target type as an argument along with the code block to be run
when the event is triggered.</p>


          <pre>  x = []

  When(:step) do |section|
    section.text.scan(/^\*(.*?)$/) do |m|
      x << $1.strip
    end
  end

</pre>
        </div>
        <div class="test pass">
          
<p>Now let’s see if it worked.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          <ul><li>
<p>SampleA</p>
</li><li>
<p>SampleB</p>
</li><li>
<p>SampleC</p>
</li></ul>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>So <code>x</code> should now contain these three list samples.</p>


          <pre>  x.assert == [ 'SampleA', 'SampleB', 'SampleC' ]

</pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Pattern+Matchers">Pattern Matchers</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>QED also supports comment match triggers. With the <code>When</code> method
one can define procedures to run when a given pattern matches comment text.</p>


          <pre>    When 'given the facts' do
      @facts = "this is truth"
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Then whenever the words, ‘<strong>given the facts</strong>’ appear in step
description the `@facts` varaible will be set.</p>


          <pre>    @facts.assert == "this is truth"

</pre>
        </div>
        <div class="test pass">
          
<p>Pattern matchers reall shine when we also add captures to the mix.</p>


          <pre>    When 'given a setting @a equal to (((\d+)))' do |n|
      @a = n.to_i
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Now, @a will be set to 1 whenever a comment like this one contains,
“<strong>given a setting @a equal to 1</strong>”.</p>


          <pre>    @a.assert == 1

</pre>
        </div>
        <div class="test pass">
          
<p>A string pattern is translated into a regular expression. In fact, you can
use a regular expression if you need more control over the match. When
using a string all spaces are converted to <code>\s+</code> and anything
within double-parenthesis is treated as raw regular expression. Since the
above example has (((d+))), the actual regular expression contains
<code>(\d+)</code>, so any number can be used. For example, “<strong>given
a setting @a equal to 2</strong>”.</p>


          <pre>    @a.assert == 2

</pre>
        </div>
        <div class="test pass">
          
<p>When clauses can also use consecutive pattern matching. For instance we
could write,</p>


          <pre>    When 'first match #(((\d+)))', 'then match #(((\d+)))' do |i1, i2|
      @a = [i1.to_i, i2.to_i]
    end

</pre>
        </div>
        <div class="test pass">
          
<p>So that ‘<strong>first match #1</strong>’ will be looked for first, and
only after that if ‘<strong>then match #2</strong>’ is found, will it be
considered a complete match. All regular expression slots are collected
from all matches and passed to the block. We can see that the rule matched
this very paragraph.</p>


          <pre>  @a.assert == [1,2]

</pre>
        </div>
        <div class="test pass">
          
<p>This concludes the basic overview of QED’s specification system, which is
itself a QED document. Yes, we eat our own dog food.</p>


          <pre></pre>
        </div>
        <h2>qed/03_helpers.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Helpers">Helpers</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>There are two ways to load advice scripts. Manually loaded helpers act per
demonstrandum and apply only to the currently executing demo. Automaticly
loaded helpers apply to all  demonstrandum within their preview.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Helper scripts can be written just like demonstration scripts, or they can
be defined as pure Ruby scripts.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Automatic+Helpers">Automatic Helpers</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Automatic helpers, known as the “applique” are loaded at the start of a
session and apply equally to all demonstrandum within the same or lower
directory as teh demo. These helpers are placed in an <code>applique</code>
subdirectory. For instance this document uses, <a
href="http://applique/env.rb">applique/env.rb</a>.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Manual+Helpers">Manual Helpers</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Manual helpers are loaded per-demonstration by using specially marked
links.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>For example, because this link, <a
href="qed://helpers/advice.rb">Advice</a>, begins with <code>qed:</code>,
it will be used to load a helper. We can  see this with the following
assertion.</p>


          <pre>  pudding.assert.include?('loaded advice.rb')

</pre>
        </div>
        <div class="test pass">
          
<p>No where in the demonstration have we defined <code>pudding</code>, but it
has been defined for us in the advice.rb helper script.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>We can also see that the generic When clause in our advice helper is
keeping count of decriptive paragraphs. Since the helper script was loaded
two paragraphs back, the next count will be 3.</p>


          <pre>  count.assert == 3

</pre>
        </div>
        <div class="test pass">
          
<p>Helpers are vital to building test-demonstration suites for applications.
But here again, only use them as necessary. The more helpers you use the
more difficult your demos will be to follow.</p>


          <pre></pre>
        </div>
        <h2>qed/04_samples.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Test+Samples">Test Samples</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Flat-file+Data">Flat-file Data</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>When creating testable demonstrations, there are times when sizable chunks
of data are needed. It is convenient to store such data in separate files.
The <code>Data</code> method makes is easy to utilize them.</p>


          <pre>    Data(File.dirname(__FILE__) + '/samples/data.txt').assert =~ /dolor/

</pre>
        </div>
        <div class="test pass">
          
<p>The <code>Data</code> method can also take a block which passes the data as
the blocks only argument.</p>


          <pre>    Data(File.dirname(__FILE__) + '/samples/data.txt') do |data|
      data.assert =~ /dolor/
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Files are looked-up relative to the location of the current document. If
not found then they will be looked-up relative to the current working
directory.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Tabular+Data">Tabular Data</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>The <code>Table</code> method is similar to the <code>Data</code> method
except that it expects a YAML file, and it can take a block to iterate the
data over. This makes it easy to test tables of examples.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>The arity of the table block corresponds to the number of columns in each
row of the table. Each row is assigned in turn and run through the coded
step. Consider the following example.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Every row in the <a href="http://table.yml">table.yml table</a> will be
assigned to the block parameters and run through the subsequent assertion.</p>


          <pre>    Table File.dirname(__FILE__) + '/samples/table.yml' do |x, y|
      x.upcase.assert == y
    end

</pre>
        </div>
        <div class="test pass">
          
<p>Without the block, the <code>Table</code> methods simply returns the sample
data.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Considerations">Considerations</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Both Data and Table are some what “old fashion” approches to sample data.
New techinques using plain text blocks are more convenient in that the data
can be stored directly in the demonstration itself. However, for especially
large data sets and external file is still the better option, and
<code>Data</code> and <code>Table</code> make them quite easy to access.</p>


          <pre></pre>
        </div>
        <h2>qed/05_quote.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Quotes">Quotes</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>We do not always want verbatim clauses to be interpreted as code. Sometimes
it would more useful to treat them a plain text to  which the preceeding
paragraph can make use in a processing rule.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>For example let say <strong>we want to make an example out of the following
text</strong>:</p>


          <pre>  The file will contain

  this text

</pre>
        </div>
        <div class="test pass">
          
<p>The use of the colon (`:`) tells the processor that the next segment is a
plain text continuation of the current segment, rather than executable
code. If the next segment is varbatim it will be added to the end of the
arguments list of any applicable processing rule.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Behind the scenes we created a rule to set the text to an instance variable
called @quote_text, and we can verify it is so.</p>


          <pre>  @quote_text.assert == "The file will contain\n\nthis text"

</pre>
        </div>
        <div class="test pass">
          
<p>Alternately we can use a colon (‘:’) instead of ellipsis. We can repeat the
same statment as above.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>For example let say <strong>we want to make an example out of the following
text</strong>:</p>


          <pre>  The file will contain

  different text

</pre>
        </div>
        <div class="test pass">
          
<p>And again we can verify that it did in fact set the @quote_text variable.</p>


          <pre>  @quote_text.assert == "The file will contain\n\ndifferent text"

</pre>
        </div>
        <h2>qed/07_toplevel.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Toplevel+Simulation">Toplevel Simulation</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>QED simulates Ruby’s TOPLEVEL environment in both the Demonstrandum and the
Applique contexts. This serves two important purposes. First, it provides
the tester the environment that is most intutive. And second, and more
importantly, it stays out of the actual TOPLEVEL space to prevent any
potential interferece with any of  the code it is intended to test.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Let’s look at some examples. For starters, we have access to a class
defined at the “toplevel” in the applique.</p>


          <pre>  ToplevelClass

</pre>
        </div>
        <div class="test pass">
          
<p>We can also call a method defined in the toplevel.</p>


          <pre>  toplevel_method.assert == true

</pre>
        </div>
        <div class="test pass">
          
<p>At the demonstrandum level we can define reusable methods.</p>


          <pre>  def demo_method
    true
  end

  demo_method.assert == true

</pre>
        </div>
        <div class="test pass">
          
<p>And at the demonstrandum level even singleton methods are accessible.</p>


          <pre>  def self.singleton_method; true; end

  singleton_method.assert == true

</pre>
        </div>
        <div class="test pass">
          
<p>QED uses a self-extend modules to achieve this simulation, so the contexts
are in fact a bit more capable then even Ruby’s TOPLEVEL. For instance,
#define_method can be used.</p>


          <pre>  define_method(:named_method){ true }

  named_method.assert == true

</pre>
        </div>
        <h2>qed/08_cross_script.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Cross-Scripting+Setup">Cross-Scripting Setup</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>We define some variables here to make sure it is not visible in the next
script.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Let’s set two local variables.</p>


          <pre>  a = 100
  b = 200

</pre>
        </div>
        <div class="test pass">
          
<p>And two instance varaibles.</p>


          <pre>  @a = 1000
  @b = 2000

</pre>
        </div>
        <div class="test pass">
          
<p>Also let check how it effect constants.</p>


          <pre>  CROSS_SCRIPT_CONSTANT = "cross?"

</pre>
        </div>
        <div class="test pass">
          
<p>And a method.</p>


          <pre>  def cross_script_method
    "common"
  end

</pre>
        </div>
        <h2>qed/09_cross_script.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Cross-Scripting+Check">Cross-Scripting Check</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Make sure local and instance variables from previous QED scripts are not
visible in this document.</p>


          <pre>  expect NameError do
    a.assert = 100
    b.assert = 200
  end

</pre>
        </div>
        <div class="test pass">
          
<p>And two instance_varaibles</p>


          <pre>  @a.assert! == 1000
  @b.assert! == 2000


</pre>
        </div>
        <div class="test pass">
          
<p>Method definitions also do not cross QED scripts.</p>


          <pre>  expect NameError do
    cross_script_method
  end

</pre>
        </div>
        <div class="test pass">
          
<p>Since each demo is encapsulated in a separated class scope, constants also
do not make their way across.</p>


          <pre>  expect NameError do
    CROSS_SCRIPT_CONSTANT
  end

</pre>
        </div>
        <h2>qed/10_constant_lookup.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Missing+Constant">Missing Constant</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>If a constant is missing it is because it was not found in either the demos
scope, the applique or at the toplevel.</p>


          <pre>  begin
    UnknownConstant
  rescue => err
    # no colon means toplevel
    err.name.to_s.refute.include?('::')
  end

</pre>
        </div>
        <div class="test pass">
          
<p>A constant defined in the applique is visible.</p>


          <pre>  APPLIQUE_CONSTANT.assert = true

</pre>
        </div>
        <h2>qed/11_embedded_rules.rdoc</h2>
        <div class="test pass">
          
<h1 id="label-Meta+Code">Meta Code</h1>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>Now, let’s try it by saying, “<strong>this is cool</strong>”:</p>


          <pre>  And this is the text.

</pre>
        </div>
        <div class="test pass">
          
<p>Did it work?</p>


          <pre>  @text.assert == "And this is the text."


</pre>
        </div>
        <div class="test pass">
          
<h2 id="label-Match+Separator">Match Separator</h2>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>The `When` method can take a list of String or Regexp as arguments. If any
of the strings contain `…`, the string will be split into two at this
point, which effective means that any text can occur within this space. It
behaves much like adding `((*.?))`, but parses more quickly by dividing the
string into multiple matches.</p>


          <pre>  When 'Let /(\w+)/ be ... scared of /(\w+)/' do |name, monster|
    @name    = name
    @monster = monster
  end

</pre>
        </div>
        <div class="test pass">
          
<p>Okay let’s try it: <strong>Let John be</strong> very <strong>scared of
Zombies</strong>.</p>


          <pre></pre>
        </div>
        <div class="test pass">
          
<p>So now what is the name?</p>


          <pre>  @name.assert == "John"

</pre>
        </div>
        <div class="test pass">
          
<p>What is the monster?</p>


          <pre>  @monster.assert == "Zombies"

</pre>
        </div>
        <div class="test pass">
          
<p>Did it work?</p>


          <pre></pre>
        </div>
        <h2>qed/99_issues/02_topcode.rdoc</h2>
        <div class="test pass">
          

          <pre>  x = "Is this running?" 
  x.assert == "Is this running?"

</pre>
        </div>
        <div class="test pass">
          
<p>This demo simply checks to make sure top code is exectued like any other
code when there is no prior description.</p>


          <pre>  x.assert == "Is this running?"

</pre>
        </div>
        </body>
        </html>
