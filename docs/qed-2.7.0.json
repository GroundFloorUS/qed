{"(metadata)":{"source":["var"],"source_url":"http://raw.github.com/rubyworks/qed/master","authors":[{"name":"Trans","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer, Rubyworks","year":"2006","license":"BSD-2-Clause"}],"replacements":[],"alternatives":[],"requirements":[{"name":"ansi"},{"name":"facets","version":"2.8+"},{"name":"ae","version":"1.7+"},{"name":"confection"},{"name":"detroit","groups":["build"],"development":true}],"dependencies":[],"conflicts":[],"repositories":[{"uri":"git://github.com/rubyworks/qed.git","scm":"git","name":"upstream"}],"resources":{"home":"http://rubyworks.github.com/qed","code":"http://github.com/rubyworks/qed","mail":"http://groups.google.com/groups/rubyworks-mailinglist","bugs":"http://github.com/rubyworks/qed/issues"},"extra":{},"load_path":["lib"],"revision":0,"created":"2006-12-16","summary":"Quod Erat Demonstrandum","title":"QED","version":"2.7.0","name":"qed","description":"QED (Quality Ensured Demonstrations) is a TDD/BDD framework\nutilizing Literate Programming techniques.","date":"2011-11-18","path":"(metadata)","markup":"rdoc"},"QED":{"!":"module","path":"QED","name":"QED","namespace":"","comment":"require 'nokogiri'","format":"rdoc","constants":["QED::VERSION"],"includes":[],"extensions":[],"modules":["QED::Reporter","QED::FileFixtures"],"classes":["QED::Step","QED::Demo","QED::Scope","QED::Parser","QED::Session","QED::QuickParser","QED::Settings","QED::Document","QED::Template","QED::Applique","QED::Evaluator"],"methods":["QED.metadata","QED.const_missing","QED.all_steps","QED.cli"],"accessors":[],"files":["/lib/qed/document.rb","/lib/qed.rb","/lib/qed/step.rb","/lib/qed/demo.rb","/lib/qed/scope.rb","/lib/qed/parser.rb","/lib/qed/cli/qed.rb","/lib/qed/session.rb","/lib/qed/qparser.rb","/lib/qed/settings.rb","/lib/qed/applique.rb","/lib/qed/cli/qedoc.rb","/lib/qed/evaluator.rb","/lib/qed/reporter/html.rb","/lib/qed/reporter/tapy.rb","/lib/qed/reporter/bullet.rb","/lib/qed/reporter/linear.rb","/lib/qed/document/markup.rb","/lib/qed/reporter/verbatim.rb","/lib/qed/reporter/abstract.rb","/lib/qed/reporter/dotprogress.rb","/lib/qed/helpers/file_fixtures.rb"],"tags":{}},"QED::VERSION":{"!":"constant","path":"QED::VERSION","name":"VERSION","namespace":"QED","comment":"TODO: Only b/c of Ruby 1.8.x bug.","format":"rdoc","value":"metadata['version']","tags":{},"files":["/lib/qed.rb"]},"QED.metadata":{"!":"method","declarations":["class","public"],"path":"QED.metadata","name":"metadata","namespace":"QED","comment":"Access to project metadata.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"metadata(.)","arguments":[]}],"returns":[],"file":"/lib/qed.rb","line":4,"source":"def self.metadata\n  @metadata ||= (\n    require 'yaml'\n    YAML.load(File.new(File.dirname(__FILE__) + '/qed.yml')) rescue {}\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED.const_missing":{"!":"method","declarations":["class","public"],"path":"QED.const_missing","name":"const_missing","namespace":"QED","comment":"Access to project metadata as constants.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"const_missing(.)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/qed.rb","line":12,"source":"def self.const_missing(name)\n  key = name.to_s.downcase\n  metadata[key] || super(name)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step":{"!":"class","superclass":"Object","path":"QED::Step","name":"Step","namespace":"QED","comment":"A Step consists of a flush region of text and the indented \ntext the follows it. QED breaks all demo documents down into\nthese for evaluation.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Step#file","QED::Step#lines","QED::Step#back_step","QED::Step#next_step","QED::Step#initialize","QED::Step#explain_lines","QED::Step#example_lines","QED::Step#to_s","QED::Step#explain","QED::Step#text","QED::Step#description","QED::Step#rule?","QED::Step#type","QED::Step#rule_text","QED::Step#heading?","QED::Step#data?","QED::Step#code?","QED::Step#lineno","QED::Step#explain_lineno","QED::Step#example_lineno","QED::Step#example?","QED::Step#has_example?","QED::Step#example","QED::Step#code","QED::Step#data","QED::Step#arguments","QED::Step#clean_example","QED::Step#sample_text","QED::Step#inspect","QED::Step#assertive?","QED::Step#next_step=","QED::Step#tweak_code"],"accessors":["QED::Step#file","QED::Step#lines","QED::Step#back_step","QED::Step#next_step","QED::Step#explain_lines","QED::Step#example_lines"],"files":["/lib/qed/step.rb"],"tags":{}},"QED::Step#file":{"!":"method","declarations":["instance","public"],"path":"QED::Step#file","name":"file","namespace":"QED::Step","comment":"Returns the value of attribute file","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":10,"source":"def file\n  @file\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#lines":{"!":"method","declarations":["instance","public"],"path":"QED::Step#lines","name":"lines","namespace":"QED::Step","comment":"Block lines code/text.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"lines","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":13,"source":"def lines\n  @lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#back_step":{"!":"method","declarations":["instance","public"],"path":"QED::Step#back_step","name":"back_step","namespace":"QED::Step","comment":"Previous step.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"back_step","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":16,"source":"def back_step\n  @back_step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#next_step":{"!":"method","declarations":["instance","public"],"path":"QED::Step#next_step","name":"next_step","namespace":"QED::Step","comment":"Next step.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"next_step","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":19,"source":"def next_step\n  @next_step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Step#initialize","name":"initialize","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(file, explain, example, last)","arguments":[{"name":"file"},{"name":"explain"},{"name":"example"},{"name":"last"}]}],"returns":[{"type":"Step","comment":"a new instance of Step"}],"file":"/lib/qed/step.rb","line":22,"source":"def initialize(file, explain, example, last)\n  QED.all_steps << self\n\n  @file = file\n\n  #@lines = []\n\n  @explain_lines = explain\n  @example_lines = example\n\n  @back_step = last\n  @back_step.next_step = self if @back_step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#explain_lines":{"!":"method","declarations":["instance","public"],"path":"QED::Step#explain_lines","name":"explain_lines","namespace":"QED::Step","comment":"Returns the value of attribute explain_lines","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"explain_lines","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":36,"source":"def explain_lines\n  @explain_lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#example_lines":{"!":"method","declarations":["instance","public"],"path":"QED::Step#example_lines","name":"example_lines","namespace":"QED::Step","comment":"Returns the value of attribute example_lines","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"example_lines","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":38,"source":"def example_lines\n  @example_lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#to_s":{"!":"method","declarations":["instance","public"],"path":"QED::Step#to_s","name":"to_s","namespace":"QED::Step","comment":"Full text of block.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_s()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":52,"source":"def to_s\n  (@explain_lines + @example_lines).map{ |lineno, line| line }.join(\"\")\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#explain":{"!":"method","declarations":["instance","public"],"path":"QED::Step#explain","name":"explain","namespace":"QED::Step","comment":"Description text.","format":"rdoc","aliases":["QED::Step#text","QED::Step#description"],"singleton":false,"interfaces":[{"signature":"explain()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":57,"source":"def explain\n  @explain ||= @explain_lines.map{ |lineno, line| line }.join(\"\")\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#text":{"!":"method","declarations":["instance","public"],"path":"QED::Step#text","name":"text","namespace":"QED::Step","comment":"Description text.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"explain()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":60,"source":"def explain\n  @explain ||= @explain_lines.map{ |lineno, line| line }.join(\"\")\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#description":{"!":"method","declarations":["instance","public"],"path":"QED::Step#description","name":"description","namespace":"QED::Step","comment":"Description text.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"explain()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":61,"source":"def explain\n  @explain ||= @explain_lines.map{ |lineno, line| line }.join(\"\")\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#rule?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#rule?","name":"rule?","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rule?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":64,"source":"def rule?\n  @is_rule ||= (/\\A(given|when|rule|before|after)[:.]/i.match(text))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#type":{"!":"method","declarations":["instance","public"],"path":"QED::Step#type","name":"type","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"type()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":71,"source":"def type\n  assertive? ? :eval : :proc\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#rule_text":{"!":"method","declarations":["instance","public"],"path":"QED::Step#rule_text","name":"rule_text","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rule_text()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":76,"source":"def rule_text\n  rule?.post_match.strip\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#heading?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#heading?","name":"heading?","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"heading?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":81,"source":"def heading?\n  @is_heading ||= (/\\A[=#]/ =~ text)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#data?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#data?","name":"data?","namespace":"QED::Step","comment":"Any commentary ending in `:` will mark the example\ntext as a plain text *sample* and not code to be evaluated.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"data?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":87,"source":"def data?\n  @is_data ||= text.strip.end_with?(':')\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#code?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#code?","name":"code?","namespace":"QED::Step","comment":"Is the example text code to be evaluated?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"code?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":92,"source":"def code?\n  !data? && example?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#lineno":{"!":"method","declarations":["instance","public"],"path":"QED::Step#lineno","name":"lineno","namespace":"QED::Step","comment":"First line of example text.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"lineno()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":97,"source":"def lineno\n  @lineno ||= (\n    if @example_lines.first\n      @example_lines.first.first\n    elsif @explain_lines.first\n      @explain_lines.first.first\n     else\n      1\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#explain_lineno":{"!":"method","declarations":["instance","public"],"path":"QED::Step#explain_lineno","name":"explain_lineno","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"explain_lineno()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":109,"source":"def explain_lineno\n  @explain_lines.first ? @explain_lines.first.first : 1\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#example_lineno":{"!":"method","declarations":["instance","public"],"path":"QED::Step#example_lineno","name":"example_lineno","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"example_lineno()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":113,"source":"def example_lineno\n  @example_lines.first ? @example_lines.first.first : 1\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#example?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#example?","name":"example?","namespace":"QED::Step","comment":"Does the block have an example?","format":"rdoc","aliases":["QED::Step#has_example?"],"singleton":false,"interfaces":[{"signature":"example?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":118,"source":"def example?\n  ! example.strip.empty?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#has_example?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#has_example?","name":"has_example?","namespace":"QED::Step","comment":"Does the block have an example?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"example?()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":121,"source":"def example?\n  ! example.strip.empty?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#example":{"!":"method","declarations":["instance","public"],"path":"QED::Step#example","name":"example","namespace":"QED::Step","comment":"","format":"rdoc","aliases":["QED::Step#code","QED::Step#data"],"singleton":false,"interfaces":[{"signature":"example()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":124,"source":"def example\n  @example ||= (\n    if data?\n      @example_lines.map{ |lineno, line| line }.join(\"\")\n    else\n      tweak_code\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#code":{"!":"method","declarations":["instance","public"],"path":"QED::Step#code","name":"code","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"example()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":133,"source":"def example\n  @example ||= (\n    if data?\n      @example_lines.map{ |lineno, line| line }.join(\"\")\n    else\n      tweak_code\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#data":{"!":"method","declarations":["instance","public"],"path":"QED::Step#data","name":"data","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"example()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":134,"source":"def example\n  @example ||= (\n    if data?\n      @example_lines.map{ |lineno, line| line }.join(\"\")\n    else\n      tweak_code\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#arguments":{"!":"method","declarations":["instance","public"],"path":"QED::Step#arguments","name":"arguments","namespace":"QED::Step","comment":"Returns any extra arguments the step passes along to rules.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"arguments()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":137,"source":"def arguments\n  []\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#clean_example":{"!":"method","declarations":["instance","public"],"path":"QED::Step#clean_example","name":"clean_example","namespace":"QED::Step","comment":"Clean up the example text, removing unccesseary white lines\nand triple quote brackets, but keep indention intact.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"clean_example()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":144,"source":"def clean_example\n  str = example.chomp.sub(/\\A\\n/,'')\n  if md = /\\A[\"]{3,}(.*?)[\"]{3,}\\Z/.match(str)\n    str = md[1]\n  end\n  str.rstrip\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#sample_text":{"!":"method","declarations":["instance","public"],"path":"QED::Step#sample_text","name":"sample_text","namespace":"QED::Step","comment":"When the text is sample text and passed to an adivce block, this\nprovides the prepared form of the example text, removing white lines,\ntriple quote brackets and indention.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"sample_text()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":156,"source":"def sample_text\n  str = example.tabto(0).chomp.sub(/\\A\\n/,'')\n  if md = /\\A[\"]{3,}(.*?)[\"]{3,}\\Z/.match(str)\n    str = md[1]\n  end\n  str.rstrip\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#inspect":{"!":"method","declarations":["instance","public"],"path":"QED::Step#inspect","name":"inspect","namespace":"QED::Step","comment":"TODO: object_hexid","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":165,"source":"def inspect\n  str = text[0,24].gsub(\"\\n\",\" \")\n  %[\\#<Step:#{object_id} \"#{str} ...\">]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#assertive?":{"!":"method","declarations":["instance","public"],"path":"QED::Step#assertive?","name":"assertive?","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"assertive?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/step.rb","line":171,"source":"def assertive?\n  @assertive ||= !text.strip.end_with?('^')\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#next_step=":{"!":"method","declarations":["instance","protected"],"path":"QED::Step#next_step=","name":"next_step=","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"next_step=(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/qed/step.rb","line":178,"source":"def next_step=(n)\n  @next_step = n\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Step#tweak_code":{"!":"method","declarations":["instance","private"],"path":"QED::Step#tweak_code","name":"tweak_code","namespace":"QED::Step","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"tweak_code()","arguments":[]}],"returns":[],"file":"/lib/qed/step.rb","line":185,"source":"def tweak_code\n  code = @example_lines.map{ |lineno, line| line }.join(\"\")\n  code.gsub!(/\\n\\s*\\#\\ ?\\=\\>/, '.assert = ')\n  code.gsub!(/\\s*\\#\\ ?\\=\\>/, '.assert = ')\n  code\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo":{"!":"class","superclass":"Object","path":"QED::Demo","name":"Demo","namespace":"QED","comment":"The Demo class ecapsulates a demonstrandum script.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Demo#file","QED::Demo#mode","QED::Demo#cwd","QED::Demo#scope","QED::Demo#initialize","QED::Demo#binding","QED::Demo#directory","QED::Demo#name","QED::Demo#evaluate","QED::Demo#applique","QED::Demo#applique_locations","QED::Demo#steps","QED::Demo#parse","QED::Demo#parser","QED::Demo#run","QED::Demo#fallback_cwd"],"accessors":["QED::Demo#file","QED::Demo#mode","QED::Demo#cwd","QED::Demo#scope"],"files":["/lib/qed/demo.rb"],"tags":{}},"QED::Demo#file":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#file","name":"file","namespace":"QED::Demo","comment":"Demonstrandum file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":15,"source":"def file\n  @file\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#mode":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#mode","name":"mode","namespace":"QED::Demo","comment":"Parser mode.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mode","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":18,"source":"def mode\n  @mode\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#cwd":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#cwd","name":"cwd","namespace":"QED::Demo","comment":"Working directory.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"cwd","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":21,"source":"def cwd\n  @cwd\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#scope":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#scope","name":"scope","namespace":"QED::Demo","comment":"Scope to run demonstration within. (Known as a \"World\" in Cucumber.)","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"scope","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":24,"source":"def scope\n  @scope\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#initialize","name":"initialize","namespace":"QED::Demo","comment":"New Script","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(file, options={})","arguments":[{"name":"file"},{"name":"options","default":"{}"}]}],"returns":[{"type":"Demo","comment":"a new instance of Demo"}],"file":"/lib/qed/demo.rb","line":27,"source":"def initialize(file, options={})\n  @file     = file\n  @mode     = options[:mode]\n  @cwd      = options[:at] || fallback_cwd\n\n  @applique = options[:applique]\n  @scope    = options[:scope] || Scope.new(applique, cwd, file)\n\n  @binding  = @scope.__binding__\n  #apply_environment\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#binding":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#binding","name":"binding","namespace":"QED::Demo","comment":"One binding per demo.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"binding()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":40,"source":"def binding\n  @binding #||= @scope.__binding__\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#directory":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#directory","name":"directory","namespace":"QED::Demo","comment":"Expanded dirname of +file+.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"directory()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":45,"source":"def directory\n  @directory ||= File.expand_path(File.dirname(file))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#name":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#name","name":"name","namespace":"QED::Demo","comment":"File basename less extension.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"name()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":50,"source":"def name\n  @name ||= File.basename(file).chomp(File.extname(file))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#evaluate":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#evaluate","name":"evaluate","namespace":"QED::Demo","comment":"Evaluate code in the context of demo's scope.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate(code, line)","arguments":[{"name":"code"},{"name":"line"}]}],"returns":[],"file":"/lib/qed/demo.rb","line":55,"source":"def evaluate(code, line)\n  #eval(code, @binding, @file, line)\n  @scope.evaluate(code, @file, line)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#applique":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#applique","name":"applique","namespace":"QED::Demo","comment":"Returns a cached Array of Applique modules.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"applique()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":61,"source":"def applique\n  @applique ||= (\n    list = [Applique.new]\n    applique_locations.each do |location|\n      Dir[location + '/**/*'].each do |file|\n        if File.extname(file) == '.rb'\n          list << Applique.new(file)\n        else\n          # little bit of a trick here, we create a new demo but manually\n          # set the applique. That way the applique files won't be reloaded.\n          demo = Demo.new(file, :at=>@cwd, :applique=>[Applique.new])\n          demo.run\n          list.concat(demo.applique)\n        end\n      end\n    end\n    list\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#applique_locations":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#applique_locations","name":"applique_locations","namespace":"QED::Demo","comment":"Returns a list of applique directories to be used by this\ndemonstrastion.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"applique_locations()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":88,"source":"def applique_locations\n  @applique_locations ||= (\n    locations = []\n    Dir.ascend(File.dirname(file)) do |path|\n      break if path == Dir.pwd\n      dir = File.join(path, 'applique')\n      if File.directory?(dir)\n        locations << dir\n      end\n    end\n    locations\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#steps":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#steps","name":"steps","namespace":"QED::Demo","comment":"Demo steps, cached from parsing.","format":"rdoc","aliases":["QED::Demo#parse"],"singleton":false,"interfaces":[{"signature":"steps()","arguments":[]}],"returns":[{"type":"Array","comment":"parsed steps"}],"file":"/lib/qed/demo.rb","line":105,"source":"def steps\n  @steps ||= parser.parse\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#parse":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#parse","name":"parse","namespace":"QED::Demo","comment":"Demo steps, cached from parsing.\n\nParse and cache demonstration script.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"steps()","arguments":[]}],"returns":[{"type":"Array","comment":"parsed steps"},{"type":"Array","comment":"abstract syntax tree"}],"file":"/lib/qed/demo.rb","line":112,"source":"def steps\n  @steps ||= parser.parse\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#parser":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#parser","name":"parser","namespace":"QED::Demo","comment":"Get a new Parser instance for this demo.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parser()","arguments":[]}],"returns":[{"type":"Parser","comment":"parser for this demo"}],"file":"/lib/qed/demo.rb","line":117,"source":"def parser\n  Parser.new(file, :mode=>mode)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#run":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#run","name":"run","namespace":"QED::Demo","comment":"Run demo through {Evaluator} instance with given observers.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"run(*observers)","arguments":[{"name":"*observers"}]}],"returns":[],"file":"/lib/qed/demo.rb","line":122,"source":"def run(*observers)\n  evaluator = Evaluator.new(self, *observers)\n  evaluator.run\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Demo#fallback_cwd":{"!":"method","declarations":["instance","public"],"path":"QED::Demo#fallback_cwd","name":"fallback_cwd","namespace":"QED::Demo","comment":"This shouldn't be needed, but is here as a precaution.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fallback_cwd()","arguments":[]}],"returns":[],"file":"/lib/qed/demo.rb","line":141,"source":"def fallback_cwd\n  @dir ||= File.join(Dir.tmpdir, 'qed', File.basename(Dir.pwd), Time.new.strftime(\"%Y%m%d%H%M%S\"))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope":{"!":"class","superclass":"Module","path":"QED::Scope","name":"Scope","namespace":"QED","comment":"Scope is the context in which QED documents are run.","format":"rdoc","constants":["QED::Scope::DIRECTORY"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Scope#initialize","QED::Scope#__create_clean_binding_method__","QED::Scope#include","QED::Scope#demo_directory","QED::Scope#evaluate","QED::Scope#utilize","QED::Scope#When","QED::Scope#Before","QED::Scope#After","QED::Scope#__DIR__","QED::Scope#Table","QED::Scope#Data","QED::Scope#clear_working_directory!","QED::Scope#const_missing"],"accessors":[],"files":["/lib/qed/scope.rb"],"tags":{}},"QED::Scope::DIRECTORY":{"!":"constant","path":"QED::Scope::DIRECTORY","name":"DIRECTORY","namespace":"QED::Scope","comment":"Location of `qed/scope.rb`.","format":"rdoc","value":"File.dirname(__FILE__)","tags":{},"files":["/lib/qed/scope.rb"]},"QED::Scope#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#initialize","name":"initialize","namespace":"QED::Scope","comment":"Setup new Scope instance.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(applique, cwd, file=nil)","arguments":[{"name":"applique"},{"name":"cwd"},{"name":"file","default":"nil"}]}],"returns":[{"type":"Scope","comment":"a new instance of Scope"}],"file":"/lib/qed/scope.rb","line":13,"source":"def initialize(applique, cwd, file=nil)\n  super()\n  @_applique = applique\n  @_cwd      = cwd\n  @_file     = file\n\n  @_features = []\n\n  include *applique\n\n  # TODO: custom extends?\n\n  __create_clean_binding_method__\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#__create_clean_binding_method__":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#__create_clean_binding_method__","name":"__create_clean_binding_method__","namespace":"QED::Scope","comment":"This turns out to be the key to proper scoping.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"__create_clean_binding_method__()","arguments":[]}],"returns":[],"file":"/lib/qed/scope.rb","line":29,"source":"def __create_clean_binding_method__\n  #define_method(:__binding__) do\n  #  @__binding__ ||= binding\n  #end\n  module_eval %{\n    def __binding__\n      @__binding__ ||= binding\n    end\n  }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#include":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#include","name":"include","namespace":"QED::Scope","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"include(*modules)","arguments":[{"name":"*modules"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":41,"source":"def include(*modules)\n  super(*modules)\n  extend self  # overcome dynamic inclusion problem\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#demo_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#demo_directory","name":"demo_directory","namespace":"QED::Scope","comment":"Expanded dirname of +file+.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demo_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/scope.rb","line":47,"source":"def demo_directory\n  @_demo_directory ||= File.expand_path(File.dirname(@_file))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#evaluate":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#evaluate","name":"evaluate","namespace":"QED::Scope","comment":"Evaluate code in the context of the scope's special binding.\nThe return value of the evaluation is stored in `@_`.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate(code, file=nil, line=nil)","arguments":[{"name":"code"},{"name":"file","default":"nil"},{"name":"line","default":"nil"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":54,"source":"def evaluate(code, file=nil, line=nil)\n  if file\n    @_ = eval(code, __binding__, file.to_s, line.to_i)\n  else\n    @_ = eval(code, __binding__)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#utilize":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#utilize","name":"utilize","namespace":"QED::Scope","comment":"Utilize is like #require, but will evaluate the script in the context\nof the current scope.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"utilize(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":67,"source":"def utilize(file)\n  file = Dir[DIRECTORY + \"/helpers/#{file}\"].first\n  if !file\n    require 'plugin'\n    file = Plugin.find(\"#{file}{,.rb}\", :directory=>nil)\n  end\n  if file && !@_features.include?(file)\n    code = File.read(file)\n    evaluate(code, nil, file)\n  else\n    raise LoadError, \"no such file -- #{file}\"\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#When":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#When","name":"When","namespace":"QED::Scope","comment":"Define \"when\" advice.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"When(*patterns, &procedure)","arguments":[{"name":"*patterns"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/scope.rb","line":82,"source":"def When(*patterns, &procedure)\n  patterns = patterns.map{ |pat| pat == :text ? :desc : pat }\n  @_applique.first.When(*patterns, &procedure)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#Before":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#Before","name":"Before","namespace":"QED::Scope","comment":"Define \"before\" advice. Default type is :each, which\nevaluates just before example code is run.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"Before(type=:each, &procedure)","arguments":[{"name":"type","default":":each"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/scope.rb","line":89,"source":"def Before(type=:each, &procedure)\n  type = :step if type == :each\n  type = :demo if type == :all\n  @_applique.first.Before(type, &procedure)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#After":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#After","name":"After","namespace":"QED::Scope","comment":"Define \"after\" advice. Default type is :each, which\nevaluates just after example code is run.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"After(type=:each, &procedure)","arguments":[{"name":"type","default":":each"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/scope.rb","line":97,"source":"def After(type=:each, &procedure)\n  type = :step if type == :each\n  type = :demo if type == :all\n  @_applique.first.After(type, &procedure)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#__DIR__":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#__DIR__","name":"__DIR__","namespace":"QED::Scope","comment":"Directory of current document.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"__DIR__(file=nil)","arguments":[{"name":"file","default":"nil"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":104,"source":"def __DIR__(file=nil)\n  if file\n    Dir.glob(File.join(File.dirname(@_file), file)).first || file\n  else\n    File.dirname(@_file)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#Table":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#Table","name":"Table","namespace":"QED::Scope","comment":"Use sample table to run steps. The table file is located relative to\nthe demo, failing that it will be looked for relative to the working\ndirectory.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"Table(file=nil, options={})","arguments":[{"name":"file","default":"nil"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":120,"source":"def Table(file=nil, options={}) #:yield:\n  if file\n    file = Dir.glob(File.join(File.dirname(@_file), file)).first || file\n  else\n    file = @_last_table\n  end\n  @_last_table = file\n\n  file_handle = File.new(file)\n\n  if options[:stream]\n    if block_given?\n      YAML.load_documents(file_handle) do |data|\n        yield data\n      end\n    else\n      YAML.load_stream(file_handle)\n    end\n  else\n    if block_given?\n      tbl = YAML.load(file_handle)\n      tbl.each do |data|\n        yield(*data)\n      end\n    else\n      YAML.load(file_handle)\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#Data":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#Data","name":"Data","namespace":"QED::Scope","comment":"Read a static data file and yield contents to block if given.\n\nThis method no longer automatically uses YAML.load.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"Data(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":155,"source":"def Data(file) #:yield:\n  file = Dir.glob(File.join(File.dirname(@_file), file)).first || file\n  #case File.extname(file)\n  #when '.yml', '.yaml'\n  #  data = YAML.load(File.new(file))\n  #else\n    data = File.read(file)\n  #end\n  if block_given?\n    yield(data)\n  else\n    data\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#clear_working_directory!":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#clear_working_directory!","name":"clear_working_directory!","namespace":"QED::Scope","comment":"Clear temporary work directory.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"clear_working_directory!()","arguments":[]}],"returns":[],"file":"/lib/qed/scope.rb","line":171,"source":"def clear_working_directory!\n  dir = @_cwd\n  dir = File.expand_path(dir)\n\n  if dir == '/' or dir == File.expand_path('~')\n    abort \"DANGER! Trying to use home or root as a temporary directory!\"\n  end\n\n  entries = Dir.glob(File.join(dir, '**/*'))\n\n  dirs, files = entries.partition{ |f| File.directory?(f) }\n\n  files.each { |file| FileUtils.rm(file)   }\n  dirs.each  { |dir|  FileUtils.rmdir(dir) }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Scope#const_missing":{"!":"method","declarations":["instance","public"],"path":"QED::Scope#const_missing","name":"const_missing","namespace":"QED::Scope","comment":"Redirect constant missing to toplevel (i.e. Object). This is \nto allow the evaluation scope to emulate the toplevel.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"const_missing(const)","arguments":[{"name":"const"}]}],"returns":[],"file":"/lib/qed/scope.rb","line":189,"source":"def const_missing(const)\n  Object.const_get(const)\nend","language":"ruby","dynamic":true,"tags":{}},"QED.all_steps":{"!":"method","declarations":["class","public"],"path":"QED.all_steps","name":"all_steps","namespace":"QED","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"all_steps(.)","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":6,"source":"def self.all_steps\n  @all_steps ||= []\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser":{"!":"class","superclass":"Object","path":"QED::Parser","name":"Parser","namespace":"QED","comment":"The parser breaks down a demonstandum into structured object\nto passed thru the script evaluator.\n\nTechnically is defines it's own markup language but for\ninteroperability sake it is RDoc and/or Markdown.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Parser#initialize","QED::Parser#ast","QED::Parser#file","QED::Parser#options","QED::Parser#lines","QED::Parser#parse_lines","QED::Parser#parse_comment_lines","QED::Parser#parse"],"accessors":["QED::Parser#ast","QED::Parser#file","QED::Parser#options"],"files":["/lib/qed/parser.rb"],"tags":{}},"QED::Parser#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#initialize","name":"initialize","namespace":"QED::Parser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(file, options={})","arguments":[{"name":"file"},{"name":"options","default":"{}"}]}],"returns":[{"type":"Parser","comment":"a new instance of Parser"}],"file":"/lib/qed/parser.rb","line":19,"source":"def initialize(file, options={})\n  @file    = file\n  @options = options\n  @ast     = []\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#ast":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#ast","name":"ast","namespace":"QED::Parser","comment":"Abstract Syntax Tree","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"ast","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":26,"source":"def ast\n  @ast\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#file":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#file","name":"file","namespace":"QED::Parser","comment":"File to parse.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":29,"source":"def file\n  @file\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#options":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#options","name":"options","namespace":"QED::Parser","comment":"Parser options.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"options","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":32,"source":"def options\n  @options\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#lines":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#lines","name":"lines","namespace":"QED::Parser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"lines()","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":35,"source":"def lines\n  @lines ||= parse_lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#parse_lines":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#parse_lines","name":"parse_lines","namespace":"QED::Parser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parse_lines()","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":40,"source":"def parse_lines\n  case options[:mode]\n  when :comment\n    parse_comment_lines\n  else\n    index = 0  #-1\n    File.readlines(file).to_a.map do |line|\n      [index += 1, line]\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#parse_comment_lines":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#parse_comment_lines","name":"parse_comment_lines","namespace":"QED::Parser","comment":"TODO: It would be nice if we could get ther require statement for the \ncomment mode to be relative to an actual loadpath.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parse_comment_lines()","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":54,"source":"def parse_comment_lines\n  ruby_omit = false\n  rdoc_omit = false\n  lines = [\n    [0, \"Load #{File.basename(file)} script.\\n\"],\n    [0, \"\\n\"],\n    [0, \"  require '#{file}'\\n\"]\n  ]\n  index = 1\n  File.readlines(file).each do |l|\n    case l\n    when /^=begin(?!\\s+qed)/\n      ruby_omit = true\n    when /^=end/\n      ruby_omit = false\n    when /^\\s*\\#\\-\\-\\s*$/\n      rdoc_omit = true\n    when /^\\s*\\#\\+\\+\\s*$/\n      rdoc_omit = false\n    ##when /^\\s*\\#\\ \\-\\-/  # not needed just double comment\n    ##  # -- skip internal comments\n    when /^\\s*##/\n      ## skip internal comments\n    when /^\\s*\\#/\n      lines << [index, l.lstrip.sub(/^\\#\\ ?/, '')] unless (ruby_omit or rdoc_omit)\n    else\n      lines << [index, \"\\n\"] unless lines.last[1] == \"\\n\" unless (ruby_omit or rdoc_omit)\n    end\n    index += 1\n  end\n  lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Parser#parse":{"!":"method","declarations":["instance","public"],"path":"QED::Parser#parse","name":"parse","namespace":"QED::Parser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parse()","arguments":[]}],"returns":[],"file":"/lib/qed/parser.rb","line":88,"source":"def parse\n  tree     = []\n  blank    = false\n  indented = false\n  explain  = []\n  example  = [] #Step.new(file)\n\n  lines.each do |lineno, line|\n    case line\n    when /^\\s*$/  # blank line\n      blank = true\n      if indented\n        example << [lineno, line]\n      else\n        explain << [lineno, line]\n      end\n    when /\\A\\s+/  #/\\A(\\t|\\ \\ +)/  # indented\n      indented = true\n      blank    = false\n      example << [lineno, line]\n    else\n      if indented or blank\n        tree << Step.new(file, explain, example, tree.last)\n        explain, example = [], [] #Step.new(file)\n      end\n      indented = false\n      blank    = false\n      explain << [lineno, line]\n    end\n  end\n  tree << Step.new(file, explain, example, tree.last)\n  @ast = tree\nend","language":"ruby","dynamic":true,"tags":{}},"QED.cli":{"!":"method","declarations":["class","public"],"path":"QED.cli","name":"cli","namespace":"QED","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"cli(.)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/qed/cli/qed.rb","line":6,"source":"def self.cli(*argv)\n  Session.cli(*argv)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session":{"!":"class","superclass":"Object","path":"QED::Session","name":"Session","namespace":"QED","comment":"The Session class encapsulates a set of demonstrations \nand the procedure for looping through them and running\neach in turn.","format":"rdoc","constants":["QED::Session::DEFAULT_FILES","QED::Session::DEMO_TYPES","QED::Session::CODE_TYPES","QED::Session::OMIT_PATHS"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Session.cli","QED::Session.cli_parse","QED::Session.settings","QED::Session#files","QED::Session#omit","QED::Session#omit=","QED::Session#format","QED::Session#format=","QED::Session#trace","QED::Session#trace=","QED::Session#mode","QED::Session#mode=","QED::Session#loadpath","QED::Session#requires","QED::Session#rooted","QED::Session#rooted=","QED::Session#profile","QED::Session#profile=","QED::Session#settings","QED::Session#initialize","QED::Session#directory","QED::Session#require_reporters","QED::Session#reporter","QED::Session#demos","QED::Session#observers","QED::Session#run","QED::Session#clear_directory","QED::Session#prepare_loadpath","QED::Session#require_libraries","QED::Session#require_profile","QED::Session#demo_files","QED::Session#demos_in_normal_mode","QED::Session#demos_in_comment_mode","QED::Session#demos_gather","QED::Session#total_step_count"],"accessors":["QED::Session#files","QED::Session#omit","QED::Session#format","QED::Session#trace","QED::Session#mode","QED::Session#loadpath","QED::Session#requires","QED::Session#rooted","QED::Session#profile","QED::Session#settings"],"files":["/lib/qed/session.rb","/lib/qed/cli/qed.rb"],"tags":{}},"QED::Session::DEFAULT_FILES":{"!":"constant","path":"QED::Session::DEFAULT_FILES","name":"DEFAULT_FILES","namespace":"QED::Session","comment":"If files are not specified than these directories \nwill be searched.","format":"rdoc","value":"['qed', 'demo', 'spec']","tags":{},"files":["/lib/qed/session.rb"]},"QED::Session::DEMO_TYPES":{"!":"constant","path":"QED::Session::DEMO_TYPES","name":"DEMO_TYPES","namespace":"QED::Session","comment":"Default recognized demos file types.","format":"rdoc","value":"%w{qed rdoc md markdown}","tags":{},"files":["/lib/qed/session.rb"]},"QED::Session::CODE_TYPES":{"!":"constant","path":"QED::Session::CODE_TYPES","name":"CODE_TYPES","namespace":"QED::Session","comment":"","format":"rdoc","value":"%w{rb}","tags":{},"files":["/lib/qed/session.rb"]},"QED::Session::OMIT_PATHS":{"!":"constant","path":"QED::Session::OMIT_PATHS","name":"OMIT_PATHS","namespace":"QED::Session","comment":"Directory names to omit from automatic selection.","format":"rdoc","value":"%w{applique helpers support sample samples fixture fixtures}","tags":{},"files":["/lib/qed/session.rb"]},"QED::Session.cli":{"!":"method","declarations":["class","public"],"path":"QED::Session.cli","name":"cli","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"cli(.)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/qed/cli/qed.rb","line":13,"source":"def self.cli(*argv)\n  require 'optparse'\n  require 'shellwords'\n\n  files, options = cli_parse(argv)\n\n  #if files.empty?\n  #  puts \"No files.\"\n  #  exit -1\n  #end\n\n  session = Session.new(files, options)\n  success = session.run\n\n  exit -1 unless success\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session.cli_parse":{"!":"method","declarations":["class","public"],"path":"QED::Session.cli_parse","name":"cli_parse","namespace":"QED::Session","comment":"Instance of OptionParser","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"cli_parse(.)","arguments":[{"name":"argv"}]}],"returns":[],"file":"/lib/qed/cli/qed.rb","line":31,"source":"def self.cli_parse(argv)\n  options = {}\n  options_parser = OptionParser.new do |opt|\n    opt.banner = \"Usage: qed [options] <files...>\"\n\n    opt.separator(\"Custom Profiles:\") unless settings.profiles.empty?\n\n    settings.profiles.each do |name, value|\n      o = \"--#{name}\"\n      opt.on(o, \"#{name} custom profile\") do\n        options[:profile] = name.to_sym\n      end\n    end\n\n    opt.separator(\"Report Formats (pick one):\")\n    #opt.on('--dotprogress', '-d', \"use dot-progress reporter [default]\") do\n    #  options[:format] = :dotprogress\n    #end\n    opt.on('--verbatim', '-v', \"shortcut for verbatim reporter\") do\n      options[:format] = :verbatim\n    end\n    opt.on('--tapy', '-y', \"shortcut for TAP-Y reporter\") do\n      options[:format] = :tapy\n    end\n    #opt.on('--bullet', '-b', \"use bullet-point reporter\") do\n    #  options[:format] = :bullet\n    #end\n    #opt.on('--html', '-h', \"use underlying HTML reporter\") do\n    #  options[:format] = :html\n    #end\n    #opt.on('--script', \"psuedo-reporter\") do\n    #  options[:format] = :script  # psuedo-reporter\n    #end\n    opt.on('--format', '-f FORMAT', \"use custom reporter\") do |format|\n      options[:format] = format.to_sym\n    end\n\n    opt.separator(\"Control Options:\")\n    opt.on('--comment', '-c', \"run comment code\") do\n      options[:mode] = :comment\n    end\n    opt.on('--profile', '-p NAME', \"load runtime profile\") do |name|\n      options[:profile] = name\n    end\n    opt.on('--loadpath', \"-I PATH\", \"add paths to $LOAD_PATH\") do |paths|\n      options[:loadpath] = paths.split(/[:;]/).map{|d| File.expand_path(d)}\n    end\n    opt.on('--require', \"-r LIB\", \"require library\") do |paths|\n      options[:requires] = paths.split(/[:;]/)\n    end\n    opt.on('--rooted', '-R', \"run from project root instead of temporary directory\") do\n      options[:rooted] = true\n    end\n    # COMMIT:\n    #   The qed command --trace option takes a count.\n    #   Use 0 to mean all.\n    opt.on('--trace', '-t [COUNT]', \"show full backtraces for exceptions\") do |cnt|\n      #options[:trace] = true\n      ENV['trace'] = cnt\n    end\n    opt.on('--warn', \"run with warnings turned on\") do\n      $VERBOSE = true # wish this were called $WARN!\n    end\n    opt.on('--debug', \"exit immediately upon raised exception\") do\n      $DEBUG   = true\n    end\n\n    opt.separator(\"Optional Commands:\")\n    opt.on_tail('--version', \"display version\") do\n      puts \"QED #{QED::VERSION}\"\n      exit\n    end\n    opt.on_tail('--copyright', \"display copyrights\") do\n      puts \"Copyright (c) 2008 Thomas Sawyer, Apache 2.0 License\"\n      exit\n    end\n    opt.on_tail('--help', '-h', \"display this help message\") do\n      puts opt\n      exit\n    end\n  end\n  options_parser.parse!(argv)\n  return argv, options\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session.settings":{"!":"method","declarations":["class","public"],"path":"QED::Session.settings","name":"settings","namespace":"QED::Session","comment":"TODO: Pass to Session class, instead of acting global.\nIt is used at the class level to get profiles for the cli.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"settings(.)","arguments":[]}],"returns":[],"file":"/lib/qed/cli/qed.rb","line":118,"source":"def self.settings\n  @settings ||= Settings.new\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#files":{"!":"method","declarations":["instance","public"],"path":"QED::Session#files","name":"files","namespace":"QED::Session","comment":"Demonstration files (or globs).","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"files","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":26,"source":"def files\n  @files\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#omit":{"!":"method","declarations":["instance","public"],"path":"QED::Session#omit","name":"omit","namespace":"QED::Session","comment":"File patterns to omit.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"omit","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":29,"source":"def omit\n  @omit\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#omit=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#omit=","name":"omit=","namespace":"QED::Session","comment":"File patterns to omit.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"omit=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":29,"source":"def omit=(value)\n  @omit = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#format":{"!":"method","declarations":["instance","public"],"path":"QED::Session#format","name":"format","namespace":"QED::Session","comment":"Output format.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"format","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":32,"source":"def format\n  @format\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#format=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#format=","name":"format=","namespace":"QED::Session","comment":"Output format.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"format=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":32,"source":"def format=(value)\n  @format = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#trace":{"!":"method","declarations":["instance","public"],"path":"QED::Session#trace","name":"trace","namespace":"QED::Session","comment":"Trace execution?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"trace","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":35,"source":"def trace\n  @trace\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#trace=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#trace=","name":"trace=","namespace":"QED::Session","comment":"Trace execution?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"trace=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":35,"source":"def trace=(value)\n  @trace = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#mode":{"!":"method","declarations":["instance","public"],"path":"QED::Session#mode","name":"mode","namespace":"QED::Session","comment":"Parse mode.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mode","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":38,"source":"def mode\n  @mode\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#mode=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#mode=","name":"mode=","namespace":"QED::Session","comment":"Parse mode.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"mode=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":38,"source":"def mode=(value)\n  @mode = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#loadpath":{"!":"method","declarations":["instance","public"],"path":"QED::Session#loadpath","name":"loadpath","namespace":"QED::Session","comment":"Paths to be added to $LOAD_PATH.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"loadpath","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":41,"source":"def loadpath\n  @loadpath\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#requires":{"!":"method","declarations":["instance","public"],"path":"QED::Session#requires","name":"requires","namespace":"QED::Session","comment":"Libraries to be required.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"requires","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":44,"source":"def requires\n  @requires\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#rooted":{"!":"method","declarations":["instance","public"],"path":"QED::Session#rooted","name":"rooted","namespace":"QED::Session","comment":"Operate from project root?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rooted","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":47,"source":"def rooted\n  @rooted\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#rooted=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#rooted=","name":"rooted=","namespace":"QED::Session","comment":"Operate from project root?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rooted=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":47,"source":"def rooted=(value)\n  @rooted = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#profile":{"!":"method","declarations":["instance","public"],"path":"QED::Session#profile","name":"profile","namespace":"QED::Session","comment":"Selected profile.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"profile","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":50,"source":"def profile\n  @profile\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#profile=":{"!":"method","declarations":["instance","public"],"path":"QED::Session#profile=","name":"profile=","namespace":"QED::Session","comment":"Selected profile.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"profile=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/session.rb","line":50,"source":"def profile=(value)\n  @profile = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#settings":{"!":"method","declarations":["instance","public"],"path":"QED::Session#settings","name":"settings","namespace":"QED::Session","comment":"Returns instance of Settings class.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"settings","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":53,"source":"def settings\n  @settings\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Session#initialize","name":"initialize","namespace":"QED::Session","comment":"New Session","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(files, options={})","arguments":[{"name":"files"},{"name":"options","default":"{}"}]}],"returns":[{"type":"Session","comment":"a new instance of Session"}],"file":"/lib/qed/session.rb","line":56,"source":"def initialize(files, options={})\n  require_reporters\n\n  @files = [files].flatten.compact\n  @files = [DEFAULT_FILES.find{ |d| File.directory?(d) }] if @files.empty?\n  @files = @files.compact\n\n  @format    = options[:format]   || :dotprogress\n  @trace     = options[:trace]    || false\n  @mode      = options[:mode]     || nil\n  @profile   = options[:profile]  || :default\n  @loadpath  = options[:loadpath] || ['lib']\n  @requires  = options[:requires] || []\n\n  @omit      = OMIT_PATHS  # TODO: eventually make configurable\n\n  @settings  = Settings.new(options)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#directory":{"!":"method","declarations":["instance","public"],"path":"QED::Session#directory","name":"directory","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"directory()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":76,"source":"def directory\n  settings.tmpdir\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#require_reporters":{"!":"method","declarations":["instance","public"],"path":"QED::Session#require_reporters","name":"require_reporters","namespace":"QED::Session","comment":"Require all reporters.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_reporters()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":88,"source":"def require_reporters\n  Dir[File.dirname(__FILE__) + '/reporter/*'].each do |file|\n    require file\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#reporter":{"!":"method","declarations":["instance","public"],"path":"QED::Session#reporter","name":"reporter","namespace":"QED::Session","comment":"Instance of selected Reporter subclass.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"reporter()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":95,"source":"def reporter\n  @reporter ||= (\n    name = Reporter.constants.find{ |c| /#{format}/ =~ c.to_s.downcase }\n    Reporter.const_get(name).new(:trace => trace)\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#demos":{"!":"method","declarations":["instance","public"],"path":"QED::Session#demos","name":"demos","namespace":"QED::Session","comment":"Returns an Array of Demo instances.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demos()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":105,"source":"def demos\n  @demos ||= demo_files.map{ |file| Demo.new(file, :mode=>mode, :at=>directory) }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#observers":{"!":"method","declarations":["instance","public"],"path":"QED::Session#observers","name":"observers","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"observers()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":110,"source":"def observers\n  [reporter]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#run":{"!":"method","declarations":["instance","public"],"path":"QED::Session#run","name":"run","namespace":"QED::Session","comment":"Run session.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"run()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":117,"source":"def run\n  abort \"No documents.\" if demo_files.empty?\n\n  clear_directory\n\n  prepare_loadpath\n  require_libraries\n\n  require_profile  # TODO: here or in chdir?\n\n  Dir.chdir(directory) do\n    # pre-parse demos\n    demos.each{ |demo| demo.steps }\n\n    # Let's do it.\n    observers.each{ |o| o.before_session(self) }\n    begin\n      demos.each do |demo|\n        demo.run(*observers)\n        #pid = fork { demo.run(*observers) }\n        #Process.detach(pid)\n      end\n    ensure\n      observers.each{ |o| o.after_session(self) }\n    end\n  end\n\n  reporter.success?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#clear_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Session#clear_directory","name":"clear_directory","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"clear_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":148,"source":"def clear_directory\n  settings.clear_directory\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#prepare_loadpath":{"!":"method","declarations":["instance","public"],"path":"QED::Session#prepare_loadpath","name":"prepare_loadpath","namespace":"QED::Session","comment":"Add to load path (from -I option).","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"prepare_loadpath()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":153,"source":"def prepare_loadpath\n  loadpath.each{ |dir| $LOAD_PATH.unshift(File.expand_path(dir)) }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#require_libraries":{"!":"method","declarations":["instance","public"],"path":"QED::Session#require_libraries","name":"require_libraries","namespace":"QED::Session","comment":"Require libraries (from -r option).","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_libraries()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":158,"source":"def require_libraries\n  requires.each{ |file| require(file) }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#require_profile":{"!":"method","declarations":["instance","public"],"path":"QED::Session#require_profile","name":"require_profile","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_profile()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":163,"source":"def require_profile\n  settings.load_profile(profile)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#demo_files":{"!":"method","declarations":["instance","public"],"path":"QED::Session#demo_files","name":"demo_files","namespace":"QED::Session","comment":"Returns a list of demo files. The files returned depends on the\n+files+ attribute and if none given, then the current run mode.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demo_files()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":169,"source":"def demo_files\n  @demo_files ||= (\n    if mode == :comment\n      demos_in_comment_mode\n    else\n      demos_in_normal_mode\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#demos_in_normal_mode":{"!":"method","declarations":["instance","public"],"path":"QED::Session#demos_in_normal_mode","name":"demos_in_normal_mode","namespace":"QED::Session","comment":"Collect default files to process in normal demo mode.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demos_in_normal_mode()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":180,"source":"def demos_in_normal_mode\n  demos_gather #(DEMO_TYPES)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#demos_in_comment_mode":{"!":"method","declarations":["instance","public"],"path":"QED::Session#demos_in_comment_mode","name":"demos_in_comment_mode","namespace":"QED::Session","comment":"Collect default files to process in code comment mode.\n\nTODO: Sure removing applique files is the best approach here?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demos_in_comment_mode()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":187,"source":"def demos_in_comment_mode\n  files = demos_gather(CODE_TYPES)\n  files = files.reject{ |f| f.index('applique/') }  # don't include applique files ???\n  files\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#demos_gather":{"!":"method","declarations":["instance","public"],"path":"QED::Session#demos_gather","name":"demos_gather","namespace":"QED::Session","comment":"Gather list of demo files. Uses +omit+ to remove certain files\nbased on the name of their parent directory.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demos_gather(extensions=DEMO_TYPES)","arguments":[{"name":"extensions","default":"DEMO_TYPES"}]}],"returns":[],"file":"/lib/qed/session.rb","line":195,"source":"def demos_gather(extensions=DEMO_TYPES)\n  files = self.files\n  #files << default_location if files.empty?\n  files = files.map{|pattern| Dir[pattern]}.flatten.uniq\n  files = files.map do |file|\n    if File.directory?(file)\n      Dir[File.join(file,'**','*.{' + extensions.join(',') + '}')]\n    else\n      file\n    end\n  end\n  files = files.flatten.uniq\n  #files = files.reject{ |f| f =~ Regexp.new(\"/\\/(#{omit.join('|')})\\//\") }\n  files = files.reject{ |f| omit.any?{ |o| f.index(\"/#{o}/\") } }\n  files.map{|f| File.expand_path(f) }.uniq.sort\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Session#total_step_count":{"!":"method","declarations":["instance","public"],"path":"QED::Session#total_step_count","name":"total_step_count","namespace":"QED::Session","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"total_step_count()","arguments":[]}],"returns":[],"file":"/lib/qed/session.rb","line":220,"source":"def total_step_count\n  count = 0\n  QED.all_steps.each do |step|\n    count += 1 unless step.heading?\n  end\n  count\nend","language":"ruby","dynamic":true,"tags":{}},"QED::QuickParser":{"!":"class","superclass":"Object","path":"QED::QuickParser","name":"QuickParser","namespace":"QED","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::QuickParser#initialize","QED::QuickParser#parse"],"accessors":[],"files":["/lib/qed/qparser.rb"],"tags":{}},"QED::QuickParser#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::QuickParser#initialize","name":"initialize","namespace":"QED::QuickParser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(demo)","arguments":[{"name":"demo"}]}],"returns":[{"type":"QuickParser","comment":"a new instance of QuickParser"}],"file":"/lib/qed/qparser.rb","line":6,"source":"def initialize(demo)\n  @lines = demo.lines\nend","language":"ruby","dynamic":true,"tags":{}},"QED::QuickParser#parse":{"!":"method","declarations":["instance","public"],"path":"QED::QuickParser#parse","name":"parse","namespace":"QED::QuickParser","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parse()","arguments":[]}],"returns":[],"file":"/lib/qed/qparser.rb","line":11,"source":"def parse\n  flush  = true\n  script = []\n\n  @lines.each do |line|\n    case line\n    when /^\\s/\n      if flush\n        script << \"Test do\\n\"\n      end\n      script << line\n      flush = false\n    else\n      if !flush\n        script << \"end\"\n      end\n      script << \"# \" + line\n      flush = true\n    end\n  end\n\n  script.join()\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings":{"!":"class","superclass":"Object","path":"QED::Settings","name":"Settings","namespace":"QED","comment":"Ecapsulate configuration information needed for QED to\nrun and set user and project options.\n\nConfiguration for QED is placed in a `.config.rb` or `config.rb` file.\nIn this file special configuration setups can be placed to automatically\neffect QED execution, in particular optional profiles can be defined.\n\n  qed do\n    profile :cov do\n      require 'simplecov'\n      SimpleCov.start do\n        coverage_dir 'log/coverage'\n        add_group \"Shared\" do |src_file|\n          /lib\\/dotruby\\/v(\\d+)(.*?)$/ !~ src_file.filename\n        end\n        add_group \"Revision 0\", \"lib/dotruby/v0\"\n      end\n    end\n  end","format":"rdoc","constants":["QED::Settings::ROOT_PATTERN","QED::Settings::HOME"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Settings#initialize","QED::Settings#rootless","QED::Settings#rootless=","QED::Settings#rootless?","QED::Settings#root_directory","QED::Settings#temporary_directory","QED::Settings#tmpdir","QED::Settings#clear_directory","QED::Settings#profile","QED::Settings#profiles","QED::Settings#profiles=","QED::Settings#load_profile","QED::Settings#find_root","QED::Settings#lookup","QED::Settings#system_tmpdir"],"accessors":["QED::Settings#rootless","QED::Settings#profiles"],"files":["/lib/qed/settings.rb"],"tags":{}},"QED::Settings::ROOT_PATTERN":{"!":"constant","path":"QED::Settings::ROOT_PATTERN","name":"ROOT_PATTERN","namespace":"QED::Settings","comment":"Glob pattern used to search for project's root directory.","format":"rdoc","value":"'{.config.rb,config.rb,.ruby,.git/,.hg/,_darcs/,lib/}'","tags":{},"files":["/lib/qed/settings.rb"]},"QED::Settings::HOME":{"!":"constant","path":"QED::Settings::HOME","name":"HOME","namespace":"QED::Settings","comment":"Home directory.","format":"rdoc","value":"File.expand_path('~')","tags":{},"files":["/lib/qed/settings.rb"]},"QED::Settings#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#initialize","name":"initialize","namespace":"QED::Settings","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(options={})","arguments":[{"name":"options","default":"{}"}]}],"returns":[{"type":"Settings","comment":"a new instance of Settings"}],"file":"/lib/qed/settings.rb","line":36,"source":"def initialize(options={})\n  @rootless = options[:rootless]\n  @profiles = {}\n\n  $ROOT = @rootless ? system_tmpdir : find_root\n\n  confection('qed').exec\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#rootless":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#rootless","name":"rootless","namespace":"QED::Settings","comment":"Returns the value of attribute rootless","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rootless","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":45,"source":"def rootless\n  @rootless\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#rootless=":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#rootless=","name":"rootless=","namespace":"QED::Settings","comment":"Sets the attribute rootless","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rootless=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/settings.rb","line":45,"source":"def rootless=(value)\n  @rootless = value\nend","language":"ruby","dynamic":true,"tags":{"param":"the value to set the attribute rootless to."}},"QED::Settings#rootless?":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#rootless?","name":"rootless?","namespace":"QED::Settings","comment":"Operate relative to project root directory, or use system's locations.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rootless?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/settings.rb","line":49,"source":"def rootless?\n  @rootless\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#root_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#root_directory","name":"root_directory","namespace":"QED::Settings","comment":"Project's root directory.\n\nCached in global variable `$ROOT`.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"root_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":56,"source":"def root_directory\n  $ROOT\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#temporary_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#temporary_directory","name":"temporary_directory","namespace":"QED::Settings","comment":"Temporary directory. If `#rootless?` return true then this will be\na system's temporary directory (e.g. `/tmp/qed/foo/20111117242323/`).\nOtherwise, it will local to the project's root int `tmp/qed/`.","format":"rdoc","aliases":["QED::Settings#tmpdir"],"singleton":false,"interfaces":[{"signature":"temporary_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":64,"source":"def temporary_directory\n  @temporary_directory ||= (\n    if rootless?\n      system_tmpdir\n    else\n      File.join(root_directory, 'tmp', 'qed')\n    end\n    #FileUtils.mkdir_p(dir) unless File.directory?(dir)\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#tmpdir":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#tmpdir","name":"tmpdir","namespace":"QED::Settings","comment":"Temporary directory. If `#rootless?` return true then this will be\na system's temporary directory (e.g. `/tmp/qed/foo/20111117242323/`).\nOtherwise, it will local to the project's root int `tmp/qed/`.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"temporary_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":76,"source":"def temporary_directory\n  @temporary_directory ||= (\n    if rootless?\n      system_tmpdir\n    else\n      File.join(root_directory, 'tmp', 'qed')\n    end\n    #FileUtils.mkdir_p(dir) unless File.directory?(dir)\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#clear_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#clear_directory","name":"clear_directory","namespace":"QED::Settings","comment":"Remove and recreate temporary working directory.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"clear_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":79,"source":"def clear_directory\n  FileUtils.rm_r(tmpdir) if File.exist?(tmpdir)\n  FileUtils.mkdir_p(tmpdir)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#profile":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#profile","name":"profile","namespace":"QED::Settings","comment":"Define a profile.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"profile(name, &block)","arguments":[{"name":"name"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/qed/settings.rb","line":85,"source":"def profile(name, &block)\n  @profiles[name.to_s] = block\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#profiles":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#profiles","name":"profiles","namespace":"QED::Settings","comment":"Keep a list of defined profiles.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"profiles","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":90,"source":"def profiles\n  @profiles\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#profiles=":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#profiles=","name":"profiles=","namespace":"QED::Settings","comment":"Keep a list of defined profiles.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"profiles=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/settings.rb","line":90,"source":"def profiles=(value)\n  @profiles = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#load_profile":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#load_profile","name":"load_profile","namespace":"QED::Settings","comment":"Load QED profile (from -e option).","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"load_profile(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/qed/settings.rb","line":103,"source":"def load_profile(name)\n  if profile = profiles[name.to_s]\n    instance_eval(&profile)\n    #eval('self', TOPLEVEL_BINDING).instance_eval(&prof)\n  end\n  #return unless settings_directory\n  #if file = Dir[\"#{settings_directory}/#{profile}.rb\"].first\n  #  require(file)\n  #end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#find_root":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#find_root","name":"find_root","namespace":"QED::Settings","comment":"Locate project's root directory. This is done by searching upward\nin the file heirarchy for the existence of one of the following\npath names, each group being tried in turn.\n\n* .git/\n* .hg/\n* _darcs/\n* .config/qed/\n* config/qed/\n* .qed/\n* .ruby\n\nFailing to find any of these locations, resort to the fallback:\n\n* lib/","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"find_root(path=nil)","arguments":[{"name":"path","default":"nil"}]}],"returns":[],"file":"/lib/qed/settings.rb","line":130,"source":"def find_root(path=nil)\n  path = File.expand_path(path || Dir.pwd)\n  path = File.dirname(path) unless File.directory?(path)\n\n  root = lookup(ROOT_PATTERN, path)\n  return root if root\n\n  #root = lookup(path, '{.qed,.config/qed,config/qed}/')\n  #return root if root\n\n  #root = lookup(path, '{qed,demo,demos}/')\n  #return root if root\n\n  root = lookup('lib/', path)\n\n  if !root\n    root = system_tmpdir\n    @rootless = true\n  end\n\n  return root\n\n  #abort \"QED failed to resolve project's root location.\\n\" +\n  #      \"QED looks for following entries to identify the root:\\n\" +\n  #      ROOT_PATTERN +\n  #      \"Please add one of them to your project to proceed.\"\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#lookup":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#lookup","name":"lookup","namespace":"QED::Settings","comment":"Lookup path +glob+, searching each higher directory\nin turn until just before the users home directory\nis reached or just before the system's root directory.\n\nTODO: include HOME directory in search?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"lookup(glob, path=Dir.pwd)","arguments":[{"name":"glob"},{"name":"path","default":"Dir.pwd"}]}],"returns":[],"file":"/lib/qed/settings.rb","line":175,"source":"def lookup(glob, path=Dir.pwd)\n  until path == HOME or path == '/' # until home or root\n    mark = Dir.glob(File.join(path,glob), File::FNM_CASEFOLD).first\n    return path if mark\n    path = File.dirname(path)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Settings#system_tmpdir":{"!":"method","declarations":["instance","public"],"path":"QED::Settings#system_tmpdir","name":"system_tmpdir","namespace":"QED::Settings","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"system_tmpdir()","arguments":[]}],"returns":[],"file":"/lib/qed/settings.rb","line":184,"source":"def system_tmpdir\n  @system_tmpdir ||= File.join(Dir.tmpdir, 'qed', File.filename(Dir.pwd), Time.new.strftime(\"%Y%m%d%H%M%S\"))\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document":{"!":"class","superclass":"Object","path":"QED::Document","name":"Document","namespace":"QED","comment":"= Document\n\nTODO: css and javascripts have fixed location need to make more flexible.\nTODO: Have option to run documents through the runner and color code output; need htmlreporter.","format":"rdoc","constants":["QED::Document::DEFAULT_TITLE","QED::Document::DEFAULT_CSS","QED::Document::DEFAULT_OUTPUT","QED::Document::DEFAULT_PATH"],"includes":[],"extensions":[],"modules":[],"classes":["QED::Document::Markup"],"methods":["QED::Document#title","QED::Document#title=","QED::Document#css","QED::Document#css=","QED::Document#dryrun","QED::Document#dryrun=","QED::Document#quiet","QED::Document#quiet=","QED::Document#output","QED::Document#output=","QED::Document#format","QED::Document#format=","QED::Document#paths","QED::Document#paths=","QED::Document#initialize","QED::Document#demo_files","QED::Document#quiet?","QED::Document#generate","QED::Document#html?","QED::Document#template","QED::Document#save","QED::Document#make_output_directory","QED::Document#file_type","QED::Document#require_qedoc","QED::Document#require_rdoc","QED::Document#require_rdiscount","QED::Document.cli"],"accessors":["QED::Document#title","QED::Document#css","QED::Document#dryrun","QED::Document#quiet","QED::Document#output","QED::Document#format","QED::Document#paths"],"files":["/lib/qed/document.rb","/lib/qed/cli/qedoc.rb","/lib/qed/document/markup.rb"],"tags":{}},"QED::Document::DEFAULT_TITLE":{"!":"constant","path":"QED::Document::DEFAULT_TITLE","name":"DEFAULT_TITLE","namespace":"QED::Document","comment":"","format":"rdoc","value":"\"Demonstration\"","tags":{},"files":["/lib/qed/document.rb"]},"QED::Document::DEFAULT_CSS":{"!":"constant","path":"QED::Document::DEFAULT_CSS","name":"DEFAULT_CSS","namespace":"QED::Document","comment":"\"../assets/styles/spec.css\"","format":"rdoc","value":"nil","tags":{},"files":["/lib/qed/document.rb"]},"QED::Document::DEFAULT_OUTPUT":{"!":"constant","path":"QED::Document::DEFAULT_OUTPUT","name":"DEFAULT_OUTPUT","namespace":"QED::Document","comment":"","format":"rdoc","value":"\"qed.html\"","tags":{},"files":["/lib/qed/document.rb"]},"QED::Document::DEFAULT_PATH":{"!":"constant","path":"QED::Document::DEFAULT_PATH","name":"DEFAULT_PATH","namespace":"QED::Document","comment":"","format":"rdoc","value":"\"qed\"","tags":{},"files":["/lib/qed/document.rb"]},"QED::Document#title":{"!":"method","declarations":["instance","public"],"path":"QED::Document#title","name":"title","namespace":"QED::Document","comment":"Returns the value of attribute title","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"title","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":19,"source":"def title\n  @title\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#title=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#title=","name":"title=","namespace":"QED::Document","comment":"Sets the attribute title","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"title=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":19,"source":"def title=(value)\n  @title = value\nend","language":"ruby","dynamic":true,"tags":{"param":"the value to set the attribute title to."}},"QED::Document#css":{"!":"method","declarations":["instance","public"],"path":"QED::Document#css","name":"css","namespace":"QED::Document","comment":"Returns the value of attribute css","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"css","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":21,"source":"def css\n  @css\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#css=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#css=","name":"css=","namespace":"QED::Document","comment":"Sets the attribute css","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"css=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":21,"source":"def css=(value)\n  @css = value\nend","language":"ruby","dynamic":true,"tags":{"param":"the value to set the attribute css to."}},"QED::Document#dryrun":{"!":"method","declarations":["instance","public"],"path":"QED::Document#dryrun","name":"dryrun","namespace":"QED::Document","comment":"Returns the value of attribute dryrun","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"dryrun","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":23,"source":"def dryrun\n  @dryrun\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#dryrun=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#dryrun=","name":"dryrun=","namespace":"QED::Document","comment":"Sets the attribute dryrun","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"dryrun=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":23,"source":"def dryrun=(value)\n  @dryrun = value\nend","language":"ruby","dynamic":true,"tags":{"param":"the value to set the attribute dryrun to."}},"QED::Document#quiet":{"!":"method","declarations":["instance","public"],"path":"QED::Document#quiet","name":"quiet","namespace":"QED::Document","comment":"Returns the value of attribute quiet","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"quiet","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":25,"source":"def quiet\n  @quiet\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#quiet=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#quiet=","name":"quiet=","namespace":"QED::Document","comment":"Sets the attribute quiet","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"quiet=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":25,"source":"def quiet=(value)\n  @quiet = value\nend","language":"ruby","dynamic":true,"tags":{"param":"the value to set the attribute quiet to."}},"QED::Document#output":{"!":"method","declarations":["instance","public"],"path":"QED::Document#output","name":"output","namespace":"QED::Document","comment":"Ouput file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"output","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":28,"source":"def output\n  @output\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#output=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#output=","name":"output=","namespace":"QED::Document","comment":"Ouput file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"output=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":28,"source":"def output=(value)\n  @output = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#format":{"!":"method","declarations":["instance","public"],"path":"QED::Document#format","name":"format","namespace":"QED::Document","comment":"Format of output file, either 'html' or 'plain'.\nDefaults to extension of output file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"format","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":32,"source":"def format\n  @format\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#format=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#format=","name":"format=","namespace":"QED::Document","comment":"Format of output file, either 'html' or 'plain'.\nDefaults to extension of output file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"format=(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/qed/document.rb","line":32,"source":"def format=(value)\n  @format = value\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#paths":{"!":"method","declarations":["instance","public"],"path":"QED::Document#paths","name":"paths","namespace":"QED::Document","comment":"Files to document.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"paths","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":35,"source":"def paths\n  @paths\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#paths=":{"!":"method","declarations":["instance","public"],"path":"QED::Document#paths=","name":"paths=","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"paths=(paths)","arguments":[{"name":"paths"}]}],"returns":[],"file":"/lib/qed/document.rb","line":38,"source":"def paths=(paths)\n  @paths = [paths].flatten\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Document#initialize","name":"initialize","namespace":"QED::Document","comment":"New Spec Document object.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(options={})","arguments":[{"name":"options","default":"{}"}]}],"returns":[{"type":"Document","comment":"a new instance of Document"}],"file":"/lib/qed/document.rb","line":43,"source":"def initialize(options={})\n  options.each do |k,v|\n    __send__(\"#{k}=\", v)\n  end\n\n  @paths  ||= []\n\n  @output ||= DEFAULT_OUTPUT\n  @title  ||= DEFAULT_TITLE\n  @css    ||= DEFAULT_CSS\n\n  if File.directory?(@output)\n    @output = File.join(@output, 'qed.html')\n  end\n\n  @format ||= File.extname(@output).sub('.','')\n\n  if @paths.empty?\n    #dir = Dir['{test/demos,demos,demo}'].first || DEFAULT_PATH\n    #@paths  = File.join(dir, '**', '*')\n    abort \"No files to document.\"\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#demo_files":{"!":"method","declarations":["instance","public"],"path":"QED::Document#demo_files","name":"demo_files","namespace":"QED::Document","comment":"Demo files.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demo_files()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":68,"source":"def demo_files\n  @demo_files ||= (\n    files = []\n    paths.each do |f|\n      if File.directory?(f)\n        files.concat Dir[File.join(f,'**','*')]\n      else\n        files.concat Dir[f]\n      end\n    end\n    files = files.reject{ |f| File.directory?(f) }\n    files = files.reject{ |f| File.extname(f) == '.rb' }\n    files = files.reject{ |f| /(fixtures|helpers)\\// =~ f }\n\n    # doesn't include .rb applique but does markup applique\n    applique, files = files.partition{ |f| /applique\\// =~ f }\n\n    applique.sort + files.sort\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#quiet?":{"!":"method","declarations":["instance","public"],"path":"QED::Document#quiet?","name":"quiet?","namespace":"QED::Document","comment":"Supress output.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"quiet?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/document.rb","line":90,"source":"def quiet?\n  @quiet\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#generate":{"!":"method","declarations":["instance","public"],"path":"QED::Document#generate","name":"generate","namespace":"QED::Document","comment":"Generate specification document.\n\n--\nTODO: Use Malt to support more formats in future.\n++","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"generate()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":99,"source":"def generate\n  #copy_support_files\n\n  out   = ''\n  files = []\n\n  #paths.each do |path|\n  #  files.concat(Dir.glob(path).select{ |f| File.file?(f) })\n  #end\n  #files.sort!\n\n  if dryrun or $DEBUG\n    puts demo_files.sort.join(\" \")\n  end\n\n  demo_files.each do |file|\n    #strio = StringIO.new('')\n    #reporter = Reporter::Html.new(strio)\n    #runner = Runner.new([file], reporter)\n    #runner.check\n    #iotext = strio.string\n    #strio.close\n\n    ext = File.extname(file)\n    txt = File.read(file)\n\n    if ext == '.qed'\n      ext = file_type(txt)\n    end\n\n    #text = Tilt.new(file).render\n    #html = Nokogiri::HTML(text)\n    #body = html.css(\"body\")\n\n    text = \"\"\n    case ext\n    #when '.qed'\n    #  require_qedoc\n    #  markup = Markup.new(File.read(file))\n    #  text << markup.to_html\n    when '.rd', '.rdoc'\n      require_rdoc\n      require_qedoc\n      if html?\n        markup = Markup.new(txt)\n        text << markup.to_html\n        #text << markup.convert(iotext, formatter)\n      else\n        text << txt\n      end        \n    when '.md', '.markdown'\n      require_rdiscount\n      if html?\n        markdown = RDiscount.new(txt)\n        text << markdown.to_html\n      else\n        text << txt\n      end\n    end\n\n    out << \"#{text}\\n\"\n  end\n\n  if html?\n    temp = Template.new(template, out, title, css)\n    html = temp.parse_template\n    save(html)\n  else\n    save(out)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#html?":{"!":"method","declarations":["instance","public"],"path":"QED::Document#html?","name":"html?","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"html?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/document.rb","line":172,"source":"def html?\n  format == 'html'\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#template":{"!":"method","declarations":["instance","public"],"path":"QED::Document#template","name":"template","namespace":"QED::Document","comment":"Load specification HTML template.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"template()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":186,"source":"def template\n  @template ||= (\n    file = File.join(File.dirname(__FILE__), 'document', 'template.rhtml')\n    File.read(file)\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#save":{"!":"method","declarations":["instance","public"],"path":"QED::Document#save","name":"save","namespace":"QED::Document","comment":"Save specification document.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"save(text)","arguments":[{"name":"text"}]}],"returns":[],"file":"/lib/qed/document.rb","line":194,"source":"def save(text)\n  if dryrun\n    puts \"[dry-run] Write #{output}\" unless quiet\n  else\n    make_output_directory\n    File.open(output, 'wb') do |f|\n      f << text\n    end\n    puts \"Write #{output}\" unless quiet\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#make_output_directory":{"!":"method","declarations":["instance","public"],"path":"QED::Document#make_output_directory","name":"make_output_directory","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"make_output_directory()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":206,"source":"def make_output_directory\n  dir = File.dirname(output)\n  FileUtils.mkdir_p(dir) unless File.directory?(dir)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#file_type":{"!":"method","declarations":["instance","private"],"path":"QED::Document#file_type","name":"file_type","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file_type(text)","arguments":[{"name":"text"}]}],"returns":[],"file":"/lib/qed/document.rb","line":214,"source":"def file_type(text)\n  rdoc = text.index(/^\\=/)\n  markdown = text.index(/^\\#/)\n  if markdown && rdoc\n    rdoc < markdown ? '.rdoc' : '.markdown'\n  elsif rdoc\n    '.rdoc'\n  elsif markdown\n    '.markdown'\n  else  # fallback to rdoc\n    '.rdoc'\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#require_qedoc":{"!":"method","declarations":["instance","private"],"path":"QED::Document#require_qedoc","name":"require_qedoc","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_qedoc()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":229,"source":"def require_qedoc\n  @require_qedoc ||= (\n    require 'qed/document/markup'\n    true\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#require_rdoc":{"!":"method","declarations":["instance","private"],"path":"QED::Document#require_rdoc","name":"require_rdoc","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_rdoc()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":237,"source":"def require_rdoc\n  @require_rdoc ||= (\n    begin\n      require 'rdoc/markup/to_html'\n    rescue LoadError\n      require 'rubygems'\n      gem 'rdoc'\n      retry\n    end\n    true\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document#require_rdiscount":{"!":"method","declarations":["instance","private"],"path":"QED::Document#require_rdiscount","name":"require_rdiscount","namespace":"QED::Document","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require_rdiscount()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":251,"source":"def require_rdiscount\n  @require_rdiscount ||= (\n    require 'rdiscount'\n    true\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Template":{"!":"class","superclass":"Object","path":"QED::Template","name":"Template","namespace":"QED","comment":"= Document Template","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Template#spec","QED::Template#title","QED::Template#css","QED::Template#initialize","QED::Template#parse_template"],"accessors":["QED::Template#spec","QED::Template#title","QED::Template#css"],"files":["/lib/qed/document.rb"],"tags":{}},"QED::Template#spec":{"!":"method","declarations":["instance","public"],"path":"QED::Template#spec","name":"spec","namespace":"QED::Template","comment":"Returns the value of attribute spec","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"spec","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":263,"source":"def spec\n  @spec\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Template#title":{"!":"method","declarations":["instance","public"],"path":"QED::Template#title","name":"title","namespace":"QED::Template","comment":"Returns the value of attribute title","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"title","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":264,"source":"def title\n  @title\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Template#css":{"!":"method","declarations":["instance","public"],"path":"QED::Template#css","name":"css","namespace":"QED::Template","comment":"Returns the value of attribute css","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"css","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":265,"source":"def css\n  @css\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Template#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Template#initialize","name":"initialize","namespace":"QED::Template","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(template, spec, title, css)","arguments":[{"name":"template"},{"name":"spec"},{"name":"title"},{"name":"css"}]}],"returns":[{"type":"Template","comment":"a new instance of Template"}],"file":"/lib/qed/document.rb","line":268,"source":"def initialize(template, spec, title, css)\n  @template = template\n  @spec     = spec\n  @title    = title\n  @css      = css\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Template#parse_template":{"!":"method","declarations":["instance","public"],"path":"QED::Template#parse_template","name":"parse_template","namespace":"QED::Template","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parse_template()","arguments":[]}],"returns":[],"file":"/lib/qed/document.rb","line":275,"source":"def parse_template\n  erb = ERB.new(@template)\n  erb.result(binding)\nend","language":"ruby","dynamic":true,"tags":{}},"Object":{"!":"class","superclass":"BasicObject","path":"Object","name":"Object","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Object::InstanceExecMethods"],"extensions":[],"modules":["Object::InstanceExecMethods"],"classes":[],"methods":["Object#instance_exec"],"accessors":[],"files":["/lib/qed/core_ext.rb"],"tags":{}},"Object::InstanceExecMethods":{"!":"module","path":"Object::InstanceExecMethods","name":"InstanceExecMethods","namespace":"Object","comment":":nodoc:","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/qed/core_ext.rb"],"tags":{}},"Object#instance_exec":{"!":"method","declarations":["instance","public"],"path":"Object#instance_exec","name":"instance_exec","namespace":"Object","comment":"Evaluate the block with the given arguments within the context of\nthis object, so self is set to the method receiver.\n\nFrom Mauricio's http://eigenclass.org/hiki/bounded+space+instance_exec\n\nThis version has been borrowed from Rails for compatibility sake.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"instance_exec(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/qed/core_ext.rb","line":19,"source":"def instance_exec(*args, &block)\n  begin\n    old_critical, Thread.critical = Thread.critical, true\n    n = 0\n    n += 1 while respond_to?(method_name = \"__instance_exec#{n}\")\n    InstanceExecMethods.module_eval { define_method(method_name, &block) }\n  ensure\n    Thread.critical = old_critical\n  end\n\n  begin\n    send(method_name, *args)\n  ensure\n    InstanceExecMethods.module_eval { remove_method(method_name) } rescue nil\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique":{"!":"class","superclass":"Module","path":"QED::Applique","name":"Applique","namespace":"QED","comment":"Applique is a module built per-script from the +applique+ directory.\nApplique scripts are loaded at the start of a session.\n\n*The Applique* is the whole collection of appliques that apply to given\ndemonstrandum. The applique that apply are the scripts located in the\ndirectory relative to the demonstrandum script and all such directories\nabove this upto and the project's root directory.\n\nAll scripts in the Applique must be compatible/consistant. For two demos to\nhave separate applique they must be kept in separate directories.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Applique.cache","QED::Applique._new","QED::Applique.new","QED::Applique#initialize","QED::Applique#initialize_copy","QED::Applique#__matchers__","QED::Applique#__signals__","QED::Applique#When","QED::Applique#Before","QED::Applique#After","QED::Applique#const_missing"],"accessors":["QED::Applique#__matchers__","QED::Applique#__signals__"],"files":["/lib/qed/applique.rb"],"tags":{}},"QED::Applique.cache":{"!":"method","declarations":["class","public"],"path":"QED::Applique.cache","name":"cache","namespace":"QED::Applique","comment":"Load cache.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"cache(.)","arguments":[]}],"returns":[],"file":"/lib/qed/applique.rb","line":17,"source":"def self.cache\n  @cache ||= {}\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique._new":{"!":"method","declarations":["class","public"],"path":"QED::Applique._new","name":"_new","namespace":"QED::Applique","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"_new","arguments":[]}],"returns":[],"file":"/lib/qed/applique.rb","line":22,"source":"alias_method :_new, :new","language":"ruby","dynamic":true,"tags":{}},"QED::Applique.new":{"!":"method","declarations":["class","public"],"path":"QED::Applique.new","name":"new","namespace":"QED::Applique","comment":"New method caches Applique based-on +file+, if given.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"new(.)","arguments":[{"name":"file","default":"nil"}]}],"returns":[],"file":"/lib/qed/applique.rb","line":28,"source":"def self.new(file=nil)\n  if file\n    cache[file] ||= _new(file)\n  else\n    _new(file)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#initialize","name":"initialize","namespace":"QED::Applique","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(file=nil)","arguments":[{"name":"file","default":"nil"}]}],"returns":[{"type":"Applique","comment":"a new instance of Applique"}],"file":"/lib/qed/applique.rb","line":37,"source":"def initialize(file=nil)\n  super()\n  extend self\n\n  @__matchers__ = []\n  @__signals__  = {}\n\n  if file\n    @file = file\n    module_eval(File.read(file), file)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#initialize_copy":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#initialize_copy","name":"initialize_copy","namespace":"QED::Applique","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize_copy(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/qed/applique.rb","line":51,"source":"def initialize_copy(other)\n  @__matchers__ = other.__matchers__.dup\n  @__signals__  = other.__signals__.dup\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#__matchers__":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#__matchers__","name":"__matchers__","namespace":"QED::Applique","comment":"Array of matchers.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"__matchers__","arguments":[]}],"returns":[],"file":"/lib/qed/applique.rb","line":57,"source":"def __matchers__\n  @__matchers__\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#__signals__":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#__signals__","name":"__signals__","namespace":"QED::Applique","comment":"Hash of signals.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"__signals__","arguments":[]}],"returns":[],"file":"/lib/qed/applique.rb","line":60,"source":"def __signals__\n  @__signals__\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#When":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#When","name":"When","namespace":"QED::Applique","comment":"Pattern matchers and \"upon\" events.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"When(*patterns, &procedure)","arguments":[{"name":"*patterns"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/applique.rb","line":63,"source":"def When(*patterns, &procedure)\n  if patterns.size == 1 && Symbol === patterns.first\n    type = \"#{patterns.first}\".to_sym\n    @__signals__[type] = procedure\n    #define_method(type, &procedure)\n  else\n    patterns = patterns.map do |p|\n      if String === p\n        p.split('...').map{ |e| e.strip } \n      else\n        p\n      end\n    end.flatten\n    @__matchers__ << [patterns, procedure]\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#Before":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#Before","name":"Before","namespace":"QED::Applique","comment":"Before advice.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"Before(type=:eval, &procedure)","arguments":[{"name":"type","default":":eval"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/applique.rb","line":81,"source":"def Before(type=:eval, &procedure)\n  type = \"before_#{type}\".to_sym\n  @__signals__[type] = procedure\n  #define_method(type, &procedure)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#After":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#After","name":"After","namespace":"QED::Applique","comment":"After advice.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"After(type=:eval, &procedure)","arguments":[{"name":"type","default":":eval"}],"block":{"name":"&procedure"}}],"returns":[],"file":"/lib/qed/applique.rb","line":88,"source":"def After(type=:eval, &procedure)\n  type = \"after_#{type}\".to_sym\n  @__signals__[type] = procedure\n  #define_method(type, &procedure)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Applique#const_missing":{"!":"method","declarations":["instance","public"],"path":"QED::Applique#const_missing","name":"const_missing","namespace":"QED::Applique","comment":"Redirect missing constants to Object classto simulate TOPLEVEL.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"const_missing(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/qed/applique.rb","line":116,"source":"def const_missing(name)\n  Object.const_get(name)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document.cli":{"!":"method","declarations":["class","public"],"path":"QED::Document.cli","name":"cli","namespace":"QED::Document","comment":"Command line interface for generating qedocs.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"cli(.)","arguments":[{"name":"*argv"}]}],"returns":[],"file":"/lib/qed/cli/qedoc.rb","line":9,"source":"def self.cli(*argv)\n\n  options = {}\n\n  parser = OptionParser.new do |usage|\n    usage.banner = \"Usage: qedoc [OPTIONS] <QEDFile1> [ <QEDFile2> ... ]\"\n\n    usage.on(\"-o\", \"--output [DIR]\", \"Output directory\") do |dir|\n      options[:output]= dir\n    end\n\n    usage.on(\"-t\", \"--title [TITLE]\", \"Title of Document\") do |title|\n      options[:title]= title\n    end\n\n    usage.on(\"--css [URI]\", \"Specify a URI for a CSS file add to HTML header.\") do |uri|\n      options[:css] = uri\n    end\n\n    usage.on(\"--dryrun\", \"\") do\n      options[:dryrun] = true\n    end\n\n    usage.on(\"-q\", \"--quiet\", \"\") do\n      options[:quiet] = true\n    end\n\n    usage.on_tail(\"-h\", \"--help\", \"display this help message\") do\n      puts usage\n      exit\n    end\n  end\n\n  parser.parse!(argv)\n\n  options[:paths] = argv.dup\n\n  #opts[:output] = cli.options[:file]\n  #opts[:dryrun] = cli.options[:dryrun]\n  #opts[:quiet]  = cli.options[:quiet]\n  #opts[:css]    = cli.options[:css]\n  #opts[:title]  = cli.options[:title]\n\n  doc = QED::Document.new(options)\n\n  doc.generate\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator":{"!":"class","superclass":"Object","path":"QED::Evaluator","name":"Evaluator","namespace":"QED","comment":"Demonstrandum Evaluator is responsible for running demo scripts.","format":"rdoc","constants":["QED::Evaluator::FORCED_EXCEPTIONS","QED::Evaluator::SPLIT_PATTERNS","QED::Evaluator::SPLIT_PATTERN"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Evaluator#initialize","QED::Evaluator#applique_observers","QED::Evaluator#run","QED::Evaluator#run_steps","QED::Evaluator#evaluate","QED::Evaluator#evaluate_links","QED::Evaluator#evaluate_procedure","QED::Evaluator#evaluate_assertion","QED::Evaluator#evaluate_code","QED::Evaluator#evaluate_matchers","QED::Evaluator#match_string_to_regexp","QED::Evaluator#pass!","QED::Evaluator#fail!","QED::Evaluator#error!","QED::Evaluator#import!","QED::Evaluator#advise!"],"accessors":[],"files":["/lib/qed/evaluator.rb"],"tags":{}},"QED::Evaluator::FORCED_EXCEPTIONS":{"!":"constant","path":"QED::Evaluator::FORCED_EXCEPTIONS","name":"FORCED_EXCEPTIONS","namespace":"QED::Evaluator","comment":", SystemExit]","format":"rdoc","value":"[NoMemoryError, SignalException, Interrupt]","tags":{},"files":["/lib/qed/evaluator.rb"]},"QED::Evaluator::SPLIT_PATTERNS":{"!":"constant","path":"QED::Evaluator::SPLIT_PATTERNS","name":"SPLIT_PATTERNS","namespace":"QED::Evaluator","comment":"","format":"rdoc","value":"[ /(\\(\\(.*?\\)\\)(?!\\)))/, /(\\/\\(.*?\\)\\/)/, /(\\/\\?.*?\\/)/ ]","tags":{},"files":["/lib/qed/evaluator.rb"]},"QED::Evaluator::SPLIT_PATTERN":{"!":"constant","path":"QED::Evaluator::SPLIT_PATTERN","name":"SPLIT_PATTERN","namespace":"QED::Evaluator","comment":"","format":"rdoc","value":"Regexp.new(SPLIT_PATTERNS.join('|'))","tags":{},"files":["/lib/qed/evaluator.rb"]},"QED::Evaluator#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#initialize","name":"initialize","namespace":"QED::Evaluator","comment":"Setup new evaluator instance.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(demo, *observers)","arguments":[{"name":"demo"},{"name":"*observers"}]}],"returns":[{"type":"Evaluator","comment":"a new instance of Evaluator"}],"file":"/lib/qed/evaluator.rb","line":11,"source":"def initialize(demo, *observers)\n  @demo  = demo\n  @steps = demo.steps\n\n  @observers = observers + applique_observers\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#applique_observers":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#applique_observers","name":"applique_observers","namespace":"QED::Evaluator","comment":"Collect applique all the signal-based advice and wrap their evaluation\nin observable procedure calls.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"applique_observers()","arguments":[]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":21,"source":"def applique_observers\n  demo = @demo\n  demo.applique.map do |a|\n    Proc.new do |type, *args|\n      proc = a.__signals__[type.to_sym] \n      demo.scope.instance_exec(*args, &proc) if proc\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#run":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#run","name":"run","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"run()","arguments":[]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":32,"source":"def run\n  advise!(:before_demo, @demo)\n  begin\n    advise!(:demo, @demo)\n    run_steps\n  ensure\n    advise!(:after_demo, @demo)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#run_steps":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#run_steps","name":"run_steps","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"run_steps()","arguments":[]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":43,"source":"def run_steps\n  @steps.each do |step|\n    evaluate(step)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate","name":"evaluate","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":49,"source":"def evaluate(step)\n  advise!(:before_step, step)\n  advise!(:step, step)\n\n  if step.assertive?\n    evaluate_links(step) unless step.heading?\n    evaluate_assertion(step)\n  else\n    evaluate_procedure(step)\n  end\n\n  advise!(:after_step, step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate_links":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate_links","name":"evaluate_links","namespace":"QED::Evaluator","comment":"If there are embedded links in the step description than extract\nthem and load them in.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate_links(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":70,"source":"def evaluate_links(step)\n  step.text.scan(/\\[qed:\\/\\/(.*?)\\]/) do |match|\n    file = $1\n    # relative to demo demo\n    if File.exist?(File.join(@demo.directory,file))\n      file = File.join(@demo.directory,file)\n    end\n    # ruby or another demo\n    case File.extname(file)\n    when '.rb'\n      import!(file)\n    else\n      Demo.new(file, :scope=>@demo.scope).run\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate_procedure":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate_procedure","name":"evaluate_procedure","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate_procedure(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":88,"source":"def evaluate_procedure(step)\n  advise!(:before_proc, step)\n  begin\n    advise!(:proc, step)\n    evaluate_matchers(step)\n    evaluate_code(step)\n  ensure\n    advise!(:after_proc, step)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate_assertion":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate_assertion","name":"evaluate_assertion","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate_assertion(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":103,"source":"def evaluate_assertion(step)\n  advise!(:before_eval, step)  # TODO: pass demo to advice?\n  begin\n    advise!(:eval, step)  # name ?\n    evaluate_matchers(step)\n    evaluate_code(step)\n  rescue *FORCED_EXCEPTIONS\n    raise\n  rescue SystemExit\n    pass!(step)\n  #rescue Assertion => exception\n  #  fail!(step, exception)\n  rescue Exception => exception\n    if exception.assertion?\n      fail!(step, exception)\n    else\n      error!(step, exception)\n    end\n  else\n    pass!(step)\n  ensure\n    advise!(:after_eval, step)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate_code":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate_code","name":"evaluate_code","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate_code(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":129,"source":"def evaluate_code(step)\n  @demo.evaluate(step.code, step.lineno) if step.code?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#evaluate_matchers":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#evaluate_matchers","name":"evaluate_matchers","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"evaluate_matchers(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":134,"source":"def evaluate_matchers(step)\n  match = step.text\n\n  @demo.applique.each do |app|\n    app.__matchers__.each do |(patterns, proc)|\n      compare = match\n      matched = true\n      params  = []\n      patterns.each do |pattern|\n        case pattern\n        when Regexp\n          regex = pattern\n        else\n          regex = match_string_to_regexp(pattern)\n        end\n        if md = regex.match(compare)\n          advise!(:match, step, md)     # ADVISE !\n          params.concat(md[1..-1])\n          compare = md.post_match\n        else\n          matched = false\n          break\n        end\n      end\n      if matched\n        #args = [params, arguments].reject{|e| e == []}  # use single argument for params in 3.0?\n        args = params\n        args = args + [step.sample_text] if step.data?\n        args = proc.arity < 0 ? args : args[0,proc.arity]\n\n        @demo.scope.instance_exec(*args, &proc)  #proc.call(*args)\n      end\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#match_string_to_regexp":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#match_string_to_regexp","name":"match_string_to_regexp","namespace":"QED::Evaluator","comment":"Convert matching string into a regular expression. If the string\ncontains double parenthesis, such as ((.*?)), then the text within\nthem is treated as in regular expression and kept verbatium.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"match_string_to_regexp(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":178,"source":"def match_string_to_regexp(str)\n  re = nil\n  str = str.split(SPLIT_PATTERN).map do |x|\n    case x\n    when /\\A\\(\\((.*?)\\)\\)(?!\\))/\n      $1\n    when /\\A\\/(\\(.*?\\))\\//\n      $1\n    when /\\A\\/(\\?.*?)\\//\n      \"(#{$1})\"\n    else\n      Regexp.escape(x)\n    end\n  end.join\n\n  str = str.gsub(/\\\\\\s+/, '\\s+')  # Replace space with variable space.\n\n  Regexp.new(str, Regexp::IGNORECASE)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#pass!":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#pass!","name":"pass!","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass!(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":237,"source":"def pass!(step)\n  advise!(:pass, step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#fail!":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#fail!","name":"fail!","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail!(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":242,"source":"def fail!(step, exception)\n  advise!(:fail, step, exception)\n  #raise exception\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#error!":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#error!","name":"error!","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error!(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":248,"source":"def error!(step, exception)\n  advise!(:error, step, exception)\n  #raise exception\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#import!":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#import!","name":"import!","namespace":"QED::Evaluator","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"import!(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":254,"source":"def import!(file)\n  advise!(:before_import, file)\n  Kernel.eval(File.read(file), @demo.binding, file)\n  advise!(:after_import, file)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Evaluator#advise!":{"!":"method","declarations":["instance","public"],"path":"QED::Evaluator#advise!","name":"advise!","namespace":"QED::Evaluator","comment":"Dispatch event to observers and advice.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"advise!(signal, *args)","arguments":[{"name":"signal"},{"name":"*args"}]}],"returns":[],"file":"/lib/qed/evaluator.rb","line":261,"source":"def advise!(signal, *args)\n  @observers.each{ |o| o.call(signal.to_sym, *args) }\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter":{"!":"module","path":"QED::Reporter","name":"Reporter","namespace":"QED","comment":":nodoc:","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["QED::Reporter::Html","QED::Reporter::TapY","QED::Reporter::BulletPoint","QED::Reporter::Linear","QED::Reporter::Verbatim","QED::Reporter::Abstract","QED::Reporter::DotProgress"],"methods":[],"accessors":[],"files":["/lib/qed/reporter/tapy.rb","/lib/qed/reporter/html.rb","/lib/qed/reporter/bullet.rb","/lib/qed/reporter/linear.rb","/lib/qed/reporter/verbatim.rb","/lib/qed/reporter/abstract.rb","/lib/qed/reporter/dotprogress.rb"],"tags":{}},"QED::Reporter::Html":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::Html","name":"Html","namespace":"QED::Reporter","comment":"= Html Reporter\n\nNOTE: This must be completely redesigned since we moved back\nto text based evaluation --which makes generting HTML with \nmodifications from the evaluation tricky. But I've come up\nwith a farily clever way to handle this. Take the original\nand use Tilt to translate it into HTML, then take the\nevaluation results for code steps and use it to search\nthe HTML for \"the closest match\". Find the \\<pre> tag\nassociated with the text and add class and color style.\nOf course the tricky part is the matching, but if we\nrun the text snippet through Tilt as well we should be\nable to get an exact match. It won't be fast, but it should\nwork.","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::Html#initialize","QED::Reporter::Html#before_session","QED::Reporter::Html#before_demo","QED::Reporter::Html#step","QED::Reporter::Html#match","QED::Reporter::Html#pass","QED::Reporter::Html#fail","QED::Reporter::Html#error","QED::Reporter::Html#after_demo","QED::Reporter::Html#after_session","QED::Reporter::Html#render","QED::Reporter::Html#rdoc"],"accessors":[],"files":["/lib/qed/reporter/html.rb"],"tags":{}},"QED::Reporter::Abstract::INFO_SIGNAL":{"!":"constant","path":"QED::Reporter::Abstract::INFO_SIGNAL","name":"INFO_SIGNAL","namespace":"QED::Reporter::Abstract","comment":"Does the system support INFO signal?","format":"rdoc","value":"Signal.list['INFO']","tags":{},"files":["/lib/qed/reporter/abstract.rb"]},"QED::Reporter::Abstract::INTERNALS":{"!":"constant","path":"QED::Reporter::Abstract::INTERNALS","name":"INTERNALS","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","value":"/(lib|bin)[\\\\\\/](qed|ae)/","tags":{},"files":["/lib/qed/reporter/abstract.rb"]},"QED::Reporter::Abstract::DEFAULT_TRACE_COUNT":{"!":"constant","path":"QED::Reporter::Abstract::DEFAULT_TRACE_COUNT","name":"DEFAULT_TRACE_COUNT","namespace":"QED::Reporter::Abstract","comment":"Default trace count. This is the number of backtrace lines that\nwill be provided on errors and failed assertions, unless otherwise\noverridden with ENV['trace'].","format":"rdoc","value":"3","tags":{},"files":["/lib/qed/reporter/abstract.rb"]},"QED::Reporter::Html#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#initialize","name":"initialize","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(*args)","arguments":[{"name":"*args"}]}],"returns":[{"type":"Html","comment":"a new instance of Html"}],"file":"/lib/qed/reporter/html.rb","line":26,"source":"def initialize(*args)\n  require 'erb'\n\n  begin\n    require 'rubygems'\n    gem 'rdoc'\n    require 'rdoc'\n  rescue\n  end\n\n  super(*args)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#before_session","name":"before_session","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":40,"source":"def before_session(session)\n  io.puts <<-END\n    <html>\n    <head>\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> \n      <title>QED Report</title>\n      <style>\n        body{width:800px; margin:0 auto;}\n        pre{font-family: courier,monospace;}\n        .pass{color: #020;}\n        .pass pre{color: green;}\n        .fail{color: #200; background: pink;}\n        .fail pre{color: green;}\n        .error{color: #200; background: pink;}\n        .error pre{color: red;}\n      </style>\n    </head>\n    <body>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#before_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#before_demo","name":"before_demo","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":62,"source":"def before_demo(demo)\n  io.puts <<-END\n    <h2>#{localize_file(demo.file)}</h2>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#step","name":"step","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":68,"source":"def step(step)\n  @_explain = step.explain.dup\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#match":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#match","name":"match","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"match(step, md)","arguments":[{"name":"step"},{"name":"md"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":73,"source":"def match(step, md)\n  #@match = md\n  unless md[0].empty?\n    @_explain.sub!(md[0], \"<b>#{md[0]}</b>\")\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#pass","name":"pass","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":81,"source":"def pass(step)\n  io.puts <<-END\n    <div class=\"test pass\">\n      #{render(@_explain)}\n\n      <pre>#{step.example}</pre>\n    </div>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#fail","name":"fail","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":92,"source":"def fail(step, assertion)\n  io.puts ERB.new(<<-END).result(binding)\n    <div class=\"test fail\">\n      #{render(@_explain)}\n\n      <pre>#{step.example}</pre>\n\n      <div class=\"assertion\">\n        <p>#{assertion.class} - #{assertion.message}</p>\n        <ol>\n        <% assertion.backtrace.each do |bt| %>\n          <li><%= bt %></li>\n        <% end %>\n        </ol>\n      </div>\n    </div>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#error","name":"error","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":112,"source":"def error(step, exception)\n  io.puts ERB.new(<<-END).result(binding)\n    <div class=\"test error\">\n      #{render(@_explain)}\n\n      <pre>#{step.example}</pre>\n\n      <div class=\"exception\">\n        <p>#{exception.class} - #{exception.message}</p>\n        <ol>\n        <% exception.backtrace.each do |bt| %>\n          <li><%= bt %></li>\n        <% end %>\n        </ol>\n      </div>\n    </div>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#after_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#after_demo","name":"after_demo","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":132,"source":"def after_demo(demo)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Html#after_session","name":"after_session","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":136,"source":"def after_session(session)\n  io.puts <<-END\n    </body>\n    </html>\n  END\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#render":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Html#render","name":"render","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"render(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":145,"source":"def render(str)\n  rdoc.convert(str.strip)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Html#rdoc":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Html#rdoc","name":"rdoc","namespace":"QED::Reporter::Html","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rdoc()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/html.rb","line":149,"source":"def rdoc\n  @rdoc ||= RDoc::Markup::ToHtml.new\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::TapY","name":"TapY","namespace":"QED::Reporter","comment":"TAP-Y Reporter \n\nNOTE: I suppose techincally that each TAP-Y test should be an assertion,\nbut that's a whole other ball of wax, and would require AE to remember\nevery assertion made. It also would have no means of providing an upfront\ncount.","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::TapY#before_session","QED::Reporter::TapY#demo","QED::Reporter::TapY#pass","QED::Reporter::TapY#fail","QED::Reporter::TapY#error","QED::Reporter::TapY#after_session","QED::Reporter::TapY#time_since_start"],"accessors":[],"files":["/lib/qed/reporter/tapy.rb"],"tags":{}},"QED::Reporter::TapY#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#before_session","name":"before_session","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":16,"source":"def before_session(session)\n  @start_time = Time.now\n\n  data = {\n    'type'  => 'suite',\n    'start' => Time.now.strftime('%Y-%m-%d %H:%M:%S'),\n    'count' => session.total_step_count,\n    'rev'   => 2\n  }\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY#demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#demo","name":"demo","namespace":"QED::Reporter::TapY","comment":"TODO: Handle cases by file or by headers?","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":29,"source":"def demo(demo)\n  data = {\n    'type'    => 'case',\n    'subtype' => 'demo',\n    'label'   => localize_file(demo.file),\n    'level'   => 0\n  }\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#pass","name":"pass","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":41,"source":"def pass(step)\n  super(step)\n\n  source_line = lines = step.text.split(\"\\n\")\n\n  #snip, l = [], step.line\n  #lines.map do |line|\n  #  snip << { (l += 1) => line }\n  #end\n\n  #if step.header?\n  #  data = {\n  #    'type'        => 'note',\n  #    'description' => step.text, #.strip,\n  #  }\n\n  data = {\n      'type'    => 'test',\n      'subtype' => 'step',\n      'status'  => 'pass',\n      'label'   => step.text.strip,\n      'file'    => localize_file(step.file),\n      'line'    => step.lineno,\n      'time'    => time_since_start\n  }\n\n      #'returned' => nil,\n      #'expected' => nil,\n\n  if step.example?\n    if step.code?\n      data.merge!(\n        'source'  => step.example_lines.first.last.strip,\n        'snippet' => step.example_lines.map{ |n, l| {n => l.rstrip} }\n      )\n    else\n      data.merge!( \n        'source'  => step.example_lines.first.last.strip,\n        'snippet' => step.example_lines.map{ |n, l| {n => l.rstrip} }\n      )\n    end\n  else\n    #data.merge!(\n    #  'source'  => step.explain_lines.first.first,\n    #  'snippet' => step.sample_text\n    #)\n  end\n\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{"todo":"How to get the line number so we can do proper snippets?"}},"QED::Reporter::TapY#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#fail","name":"fail","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":93,"source":"def fail(step, assertion)\n  super(step, assertion)\n\n  backtrace = sane_backtrace(assertion)\n\n  file, line = file_line(backtrace)\n  file = localize_file(file)\n\n  snippet = structured_code_snippet(assertion, bredth=3)\n  source  = snippet.map{ |h| h.values.first }[snippet.size / 2].strip\n\n  data = {\n    'type'        => 'test',\n    'subtype'     => 'step',\n    'status'      => 'fail',\n    'label'       => step.explain.strip,\n    'file'        => localize_file(step.file),\n    'line'        => step.explain_lineno,\n    #'returned'    => nil,\n    #'expected'    => nil,\n    'time'        => time_since_start,\n    'exception'   => {\n      'message'   => assertion.message, #unansi\n      'class'     => assertion.class.name,\n      'file'      => file,\n      'line'      => line,\n      'source'    => source,\n      'snippet'   => snippet,\n      'backtrace' => backtrace\n    }\n  }\n\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#error","name":"error","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":129,"source":"def error(step, exception)\n  super(step, exception)\n\n  backtrace = sane_backtrace(exception)\n\n  file, line = file_line(backtrace)\n  file = localize_file(file)\n\n  snippet = structured_code_snippet(exception, bredth=3)\n  source  = snippet.map{ |h| h.values.first }[snippet.size / 2].strip\n\n  data = {\n    'type'        => 'test',\n    'subtype'     => 'step',\n    'status'      => 'error',\n    'label'       => step.explain.strip,\n    'file'        => localize_file(step.file),\n    'line'        => step.explain_lineno,\n    #'returned'    => nil,\n    #'expected'    => nil,\n    'time'        => time_since_start,\n    'exception'   => {\n      'message'   => assertion.message, #unansi\n      'class'     => assertion.class.name,\n      'file'      => file,\n      'line'      => line,\n      'source'    => source,\n      'snippet'   => snippet,\n      'backtrace' => backtrace\n    }\n  }\n\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::TapY#after_session","name":"after_session","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":165,"source":"def after_session(session)\n  pass_size = steps.size - (fails.size + errors.size + omits.size)\n\n  data = {\n    'type'   => 'final',\n    'time' => time_since_start,\n    'counts' => {\n       'total' => steps.size,\n       'pass'  => pass_size,\n       'fail'  => fails.size,\n       'error' => errors.size,\n       'omit'  => omits.size,\n       'todo'  => 0\n     }\n  }\n\n  io.puts data.to_yaml\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::TapY#time_since_start":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::TapY#time_since_start","name":"time_since_start","namespace":"QED::Reporter::TapY","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"time_since_start()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/tapy.rb","line":187,"source":"def time_since_start\n  Time.now - @start_time\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::BulletPoint","name":"BulletPoint","namespace":"QED::Reporter","comment":"Bullet Point Reporter - similar to the Verbose reporter, but does\nnot display test code for passing tests.","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::BulletPoint#head","QED::Reporter::BulletPoint#desc","QED::Reporter::BulletPoint#pass","QED::Reporter::BulletPoint#fail","QED::Reporter::BulletPoint#error","QED::Reporter::BulletPoint#after_session"],"accessors":[],"files":["/lib/qed/reporter/bullet.rb"],"tags":{}},"QED::Reporter::BulletPoint#head":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#head","name":"head","namespace":"QED::Reporter::BulletPoint","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"head(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":12,"source":"def head(step)\n  io.print \"#{step}\".ansi(:bold)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint#desc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#desc","name":"desc","namespace":"QED::Reporter::BulletPoint","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"desc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":16,"source":"def desc(step)\n  txt = step.to_s.strip.tabto(2)\n  txt[0,1] = \"*\"\n  io.puts txt\n  io.puts\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#pass","name":"pass","namespace":"QED::Reporter::BulletPoint","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":23,"source":"def pass(step)\n  #io.puts \"#{step}\".ansi(:green)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#fail","name":"fail","namespace":"QED::Reporter::BulletPoint","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":27,"source":"def fail(step, assertion)\n  backtrace = sane_backtrace(assertion)\n\n  msg = []\n  msg << \"  \" + \"FAIL\".ansi(:red)\n  msg << \"\"\n  msg << assertion.to_s.gsub(/^/, '  ')\n  msg << \"\"\n  backtrace.each do |bt|\n    msg << \"  \" + relative_file(bt)\n  end\n  io.puts msg.join(\"\\n\")\n  io.puts\n  io.print step.text.tabto(4)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#error","name":"error","namespace":"QED::Reporter::BulletPoint","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":43,"source":"def error(step, exception)\n  raise exception if $DEBUG\n\n  backtrace = sane_backtrace(exception)\n\n  msg = []\n  msg << \"  \" + \"ERROR\".ansi(:red)\n  msg << \"\"\n  msg << \"  \" + exception.to_s\n  msg << \"\"\n  backtrace.each do |bt|\n    msg << \"  \" + relative_file(bt)\n  end\n  io.puts msg.join(\"\\n\")\n  io.puts\n  io.print step.text.tabto(4)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::BulletPoint#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::BulletPoint#after_session","name":"after_session","namespace":"QED::Reporter::BulletPoint","comment":"def report_macro(step)\n txt = step.to_s.tabto(2)\n txt[0,1] = \"*\"\n io.puts txt\n #io.puts\n #io.puts \"#{step}\".ansi(:magenta)\nend","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/bullet.rb","line":83,"source":"def after_session(session)\n  print_time\n  print_tally\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::Linear","name":"Linear","namespace":"QED::Reporter","comment":"Linear reporter limits each step to a single line.","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::Linear#before_session","QED::Reporter::Linear#before_demo","QED::Reporter::Linear#before_proc","QED::Reporter::Linear#pass","QED::Reporter::Linear#fail","QED::Reporter::Linear#error","QED::Reporter::Linear#after_session","QED::Reporter::Linear#timestamp","QED::Reporter::Linear#print","QED::Reporter::Linear#puts","QED::Reporter::Linear#post","QED::Reporter::Linear#print_step"],"accessors":[],"files":["/lib/qed/reporter/linear.rb"],"tags":{}},"QED::Reporter::Linear#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#before_session","name":"before_session","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":12,"source":"def before_session(session)\n  @width = ANSI::Terminal.terminal_width - 12\n  @start_time = Time.now\n  puts \"[INFO] Session @ #{Time.now}\".ansi(:bold)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#before_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#before_demo","name":"before_demo","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":19,"source":"def before_demo(demo)\n  file = localize_file(demo.file)\n  puts \"[DEMO] #{file}\".ansi(:bold)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#before_proc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#before_proc","name":"before_proc","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_proc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":25,"source":"def before_proc(step)\n  super(step)\n  #post\n  str = \"[NOTE] #{step.explain.gsub(/\\s+/,' ')} \"[0,@width]\n  pad = @width - str.size + 1\n  print str + (' ' * pad)\n  puts \"[#{timestamp}]\"\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#pass","name":"pass","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":35,"source":"def pass(step)\n  super(step)\n\n  print_step(step, 'PASS', :green)\n\n  #s = []\n  #s << \"PASS\".ansi(:green)\n  #puts s.join(\"\\n\")\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#fail","name":"fail","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":46,"source":"def fail(step, assertion)\n  super(step, assertion)\n\n  print_step(step, 'FAIL', :red)\n\n  #puts \"FAIL\".ansi(:red)\n\n  s = []\n  s << assertion.class.name\n  s << assertion.message\n\n  backtrace = sane_backtrace(assertion)\n  backtrace.each do |bt|\n    s << bt\n    s << code_snippet(bt)\n  end\n\n  puts s.join(\"\\n\").tabto(8)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#error","name":"error","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":67,"source":"def error(step, exception)\n  super(step, exception)\n\n  print_step(step, 'ERRO', :red)\n\n  #puts \"ERROR\".ansi(:red)\n\n  s = []\n  s << assertion.class.name\n  s << assertion.message\n\n  backtrace = sane_backtrace(assertion)\n  backtrace.each do |bt|\n    s << bt\n    s << code_snippet(bt)\n  end\n\n  puts s.join(\"\\n\").tabto(8)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Linear#after_session","name":"after_session","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":88,"source":"def after_session(session)\n  puts \"[INFO] %s demos, %s steps: %s failures, %s errors (%s/%s assertions)\" % get_tally\n  puts \"[INFO] Finished in %.5f seconds.\" % [Time.now - @start_time]\n  puts \"[INFO] End Session @ #{Time.now}\".ansi(:bold)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#timestamp":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Linear#timestamp","name":"timestamp","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"timestamp()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":96,"source":"def timestamp\n  (Time.now - @start_time).to_s[0,8]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#print":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Linear#print","name":"print","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"print(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":101,"source":"def print(str)\n  @appendable = true\n  io.print str\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#puts":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Linear#puts","name":"puts","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"puts(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":107,"source":"def puts(str)\n  @appendable = false\n  io.puts str\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#post":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Linear#post","name":"post","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"post()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":113,"source":"def post\n  io.puts if @appendable\n  @appendable = false\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Linear#print_step":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Linear#print_step","name":"print_step","namespace":"QED::Reporter::Linear","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"print_step(step, stat, *color)","arguments":[{"name":"step"},{"name":"stat"},{"name":"*color"}]}],"returns":[],"file":"/lib/qed/reporter/linear.rb","line":119,"source":"def print_step(step, stat, *color)\n  desc = step.explain.gsub(/\\s+/,' ')\n  if desc.start_with?('=') or desc.start_with?('#')\n    desc = desc.ansi(:magenta)\n  end\n  str = \"[#{stat}] #{desc} \"[0,@width]\n  pad = @width - str.unansi.size + 1\n  print (str + (' ' * pad)).ansi(*color)\n  puts \"[#{timestamp}]\"\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document::Markup":{"!":"class","superclass":"Object","path":"QED::Document::Markup","name":"Markup","namespace":"QED::Document","comment":"= QED Document Markup\n\nQED Document Markup is based on RDoc's SimpleMarkup format but adds\nsome additional features.\n\n* `[no-spaces]` produces <code>[no-space]</code>.\n\nFIXME: Can't get `brackets` to work.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["QED::Document::Markup::ToHTML"],"methods":["QED::Document::Markup#initialize","QED::Document::Markup#to_html","QED::Document::Markup#parser","QED::Document::Markup#formatter"],"accessors":[],"files":["/lib/qed/document/markup.rb"],"tags":{}},"QED::Document::Markup#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Document::Markup#initialize","name":"initialize","namespace":"QED::Document::Markup","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(text, options={})","arguments":[{"name":"text"},{"name":"options","default":"{}"}]}],"returns":[{"type":"Markup","comment":"a new instance of Markup"}],"file":"/lib/qed/document/markup.rb","line":18,"source":"def initialize(text, options={})\n  @text = text\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document::Markup#to_html":{"!":"method","declarations":["instance","public"],"path":"QED::Document::Markup#to_html","name":"to_html","namespace":"QED::Document::Markup","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"to_html()","arguments":[]}],"returns":[],"file":"/lib/qed/document/markup.rb","line":22,"source":"def to_html\n  parser.convert(@text, formatter)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document::Markup#parser":{"!":"method","declarations":["instance","public"],"path":"QED::Document::Markup#parser","name":"parser","namespace":"QED::Document::Markup","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parser()","arguments":[]}],"returns":[],"file":"/lib/qed/document/markup.rb","line":26,"source":"def parser\n  @parser ||= (\n    m = RDoc::Markup.new\n    #p.add_word_pair(\"{\", \"}\", :STRIKE)\n    #p.add_html(\"no\", :STRIKE)\n    #p.add_special(/\\b([A-Z][a-z]+[A-Z]\\w+)/, :WIKIWORD)\n    #m.add_word_pair('`', '`', :CODE)\n    m.add_special(/\\`(\\b.*?)\\`/, :CODE)\n    m\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document::Markup#formatter":{"!":"method","declarations":["instance","public"],"path":"QED::Document::Markup#formatter","name":"formatter","namespace":"QED::Document::Markup","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"formatter()","arguments":[]}],"returns":[],"file":"/lib/qed/document/markup.rb","line":38,"source":"def formatter\n  @formatter ||= (\n    f = ToHTML.new\n    #f.add_tag(:STRIKE, \"<strike>\", \"</strike>\")\n    f.add_tag(:CODE, \"<code>\", \"</code>\")\n    f\n  )\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Document::Markup::ToHTML":{"!":"class","superclass":"RDoc::Markup::ToHtml","path":"QED::Document::Markup::ToHTML","name":"ToHTML","namespace":"QED::Document::Markup","comment":"Formatter","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Document::Markup::ToHTML#handle_special_CODE"],"accessors":[],"files":["/lib/qed/document/markup.rb"],"tags":{}},"QED::Document::Markup::ToHTML#handle_special_CODE":{"!":"method","declarations":["instance","public"],"path":"QED::Document::Markup::ToHTML#handle_special_CODE","name":"handle_special_CODE","namespace":"QED::Document::Markup::ToHTML","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"handle_special_CODE(special)","arguments":[{"name":"special"}]}],"returns":[],"file":"/lib/qed/document/markup.rb","line":49,"source":"def handle_special_CODE(special)\n  \"<code>\" + special.text.sub('`','').chomp('`') + \"</code>\"\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::Verbatim","name":"Verbatim","namespace":"QED::Reporter","comment":"= Verbose ANSI Console Reporter","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::Verbatim#before_session","QED::Reporter::Verbatim#step","QED::Reporter::Verbatim#match","QED::Reporter::Verbatim#proc","QED::Reporter::Verbatim#pass","QED::Reporter::Verbatim#fail","QED::Reporter::Verbatim#error","QED::Reporter::Verbatim#after_session"],"accessors":[],"files":["/lib/qed/reporter/verbatim.rb"],"tags":{}},"QED::Reporter::Verbatim#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#before_session","name":"before_session","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":11,"source":"def before_session(session)\n  @start_time = Time.now\n\n  trap \"INFO\" do\n    print_time\n    print_tally\n  end if INFO_SIGNAL\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#step","name":"step","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":20,"source":"def step(step)\n  @_explain = step.explain.dup\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#match":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#match","name":"match","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"match(step, md)","arguments":[{"name":"step"},{"name":"md"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":25,"source":"def match(step, md)\n  unless md[0].empty?\n    @_explain.sub!(md[0], md[0].ansi(:bold))\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#proc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#proc","name":"proc","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"proc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":32,"source":"def proc(step)\n  io.print \"#{@_explain}\".ansi(:cyan)\n  io.print \"#{step.example}\" #.ansi(:blue)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#pass","name":"pass","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":38,"source":"def pass(step)\n  super(step)\n  if step.heading?\n    if step.code?\n      io.print \"#{@_explain}\".ansi(:bold, :cyan)\n    else\n      io.print \"#{@_explain}\".ansi(:bold)\n    end\n  else\n    io.print \"#{@_explain}\".ansi(:cyan)\n  end\n\n  if step.has_example? \n    if step.data?\n      io.print \"#{step.example}\" #.ansi(:magenta)\n    else\n      io.print \"#{step.example}\".ansi(:green)\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#fail","name":"fail","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, error)","arguments":[{"name":"step"},{"name":"error"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":60,"source":"def fail(step, error)\n  super(step, error)\n\n  tab = step.text.index(/\\S/)\n\n  if step.heading?\n    if step.code?\n      io.print \"#{@_explain}\".ansi(:bold, :magenta)\n    else\n      io.print \"#{@_explain}\".ansi(:bold)\n    end\n  else\n    io.print \"#{@_explain}\".ansi(:magenta)\n  end\n\n  if step.has_example? \n    if step.data?\n      io.print \"#{step.example}\".ansi(:red)\n    else\n      io.print \"#{step.example}\".ansi(:red)\n    end\n  end\n\n  msg = []\n  msg << \"FAIL: \".ansi(:bold, :red) + error.message.to_s #to_str\n  msg << sane_backtrace(error).join(\"\\n\").ansi(:bold)\n  msg = msg.join(\"\\n\")\n\n  io.puts msg.tabto(tab||2)\n  io.puts\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#error","name":"error","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, error)","arguments":[{"name":"step"},{"name":"error"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":93,"source":"def error(step, error)\n  super(step, error)\n\n  raise error if $DEBUG   # TODO: Should this be here?\n\n  tab = step.text.index(/\\S/)\n\n  if step.heading?\n    if step.code?\n      io.print \"#{@_explain}\".ansi(:bold, :magenta)\n    else\n      io.print \"#{@_explain}\".ansi(:bold)\n    end\n  else\n    io.print \"#{@_explain}\".ansi(:magenta)\n  end\n\n  if step.has_example? \n    if step.data?\n      io.print \"#{step.example}\".ansi(:red)\n    else\n      io.print \"#{step.example}\".ansi(:red)\n    end\n  end\n\n  msg = []\n  msg << \"ERROR: #{error.class} \".ansi(:bold,:red) + error.message #.sub(/for QED::Context.*?$/,'')\n  msg << sane_backtrace(error).join(\"\\n\").ansi(:bold)\n  msg = msg.join(\"\\n\") #.ansi(:red)\n\n  io.puts msg.tabto(tab||2)\n  io.puts\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Verbatim#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Verbatim#after_session","name":"after_session","namespace":"QED::Reporter::Verbatim","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/verbatim.rb","line":147,"source":"def after_session(session)\n  trap 'INFO', 'DEFAULT' if INFO_SIGNAL\n  print_time\n  print_tally\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract":{"!":"class","superclass":"Object","path":"QED::Reporter::Abstract","name":"Abstract","namespace":"QED::Reporter","comment":"= Reporter Absract Base Class\n\nServes as the base class for all other output formats.","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::Abstract#session","QED::Reporter::Abstract#io","QED::Reporter::Abstract#record","QED::Reporter::Abstract#initialize","QED::Reporter::Abstract#demos","QED::Reporter::Abstract#steps","QED::Reporter::Abstract#omits","QED::Reporter::Abstract#passes","QED::Reporter::Abstract#errors","QED::Reporter::Abstract#fails","QED::Reporter::Abstract#trace?","QED::Reporter::Abstract#success?","QED::Reporter::Abstract#call","QED::Reporter::Abstract.When","QED::Reporter::Abstract.Before","QED::Reporter::Abstract.After","QED::Reporter::Abstract#count_demo","QED::Reporter::Abstract#count_step","QED::Reporter::Abstract#count_pass","QED::Reporter::Abstract#count_fail","QED::Reporter::Abstract#count_error","QED::Reporter::Abstract#before_session","QED::Reporter::Abstract#before_demo","QED::Reporter::Abstract#before_step","QED::Reporter::Abstract#before_proc","QED::Reporter::Abstract#before_eval","QED::Reporter::Abstract#demo","QED::Reporter::Abstract#rule","QED::Reporter::Abstract#step","QED::Reporter::Abstract#proc","QED::Reporter::Abstract#eval","QED::Reporter::Abstract#pass","QED::Reporter::Abstract#fail","QED::Reporter::Abstract#error","QED::Reporter::Abstract#after_eval","QED::Reporter::Abstract#after_proc","QED::Reporter::Abstract#after_step","QED::Reporter::Abstract#after_demo","QED::Reporter::Abstract#after_session","QED::Reporter::Abstract#print_time","QED::Reporter::Abstract#print_tally","QED::Reporter::Abstract#get_tally","QED::Reporter::Abstract#sane_backtrace","QED::Reporter::Abstract#clean_backtrace","QED::Reporter::Abstract#code_snippet","QED::Reporter::Abstract#structured_code_snippet","QED::Reporter::Abstract#source","QED::Reporter::Abstract#file_and_line","QED::Reporter::Abstract#file_line","QED::Reporter::Abstract#trace_count","QED::Reporter::Abstract#relative_file","QED::Reporter::Abstract#localize_file"],"accessors":["QED::Reporter::Abstract#session","QED::Reporter::Abstract#io","QED::Reporter::Abstract#record"],"files":["/lib/qed/reporter/abstract.rb"],"tags":{}},"QED::Reporter::Abstract#session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#session","name":"session","namespace":"QED::Reporter::Abstract","comment":"Returns the value of attribute session","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"session","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":21,"source":"def session\n  @session\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#io":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#io","name":"io","namespace":"QED::Reporter::Abstract","comment":"Returns the value of attribute io","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"io","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":24,"source":"def io\n  @io\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#record":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#record","name":"record","namespace":"QED::Reporter::Abstract","comment":"Returns the value of attribute record","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"record","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":27,"source":"def record\n  @record\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#initialize":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#initialize","name":"initialize","namespace":"QED::Reporter::Abstract","comment":"TODO: pass session into initialize","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(options={})","arguments":[{"name":"options","default":"{}"}]}],"returns":[{"type":"Abstract","comment":"a new instance of Abstract"}],"file":"/lib/qed/reporter/abstract.rb","line":30,"source":"def initialize(options={})\n  @io    = options[:io] || STDOUT\n  @trace = options[:trace]\n\n  @record = {\n    :demo  => [],\n    :step  => [],\n    :omit  => [],\n    :pass  => [],\n    :fail  => [],\n    :error => []\n  }\n\n  #@demos = 0\n  #@steps = 0\n  #@omit  = []\n  #@pass  = []\n  #@fail  = []\n  #@error = []\n\n  @source = {}\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#demos":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#demos","name":"demos","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demos()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":53,"source":"def demos  ; @record[:demo]  ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#steps":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#steps","name":"steps","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"steps()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":54,"source":"def steps  ; @record[:step]  ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#omits":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#omits","name":"omits","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"omits()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":55,"source":"def omits  ; @record[:omit]  ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#passes":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#passes","name":"passes","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"passes()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":56,"source":"def passes ; @record[:pass]  ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#errors":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#errors","name":"errors","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"errors()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":57,"source":"def errors ; @record[:error] ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#fails":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#fails","name":"fails","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fails()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":58,"source":"def fails  ; @record[:fail]  ; end","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#trace?":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#trace?","name":"trace?","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"trace?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/reporter/abstract.rb","line":61,"source":"def trace?\n  @trace\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#success?":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#success?","name":"success?","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"success?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/qed/reporter/abstract.rb","line":66,"source":"def success?\n  record[:error].size + record[:fail].size == 0\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#call":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#call","name":"call","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"call(type, *args)","arguments":[{"name":"type"},{"name":"*args"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":71,"source":"def call(type, *args)\n  __send__(\"count_#{type}\", *args) if respond_to?(\"count_#{type}\")\n  __send__(type, *args) if respond_to?(type)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract.When":{"!":"method","declarations":["class","public"],"path":"QED::Reporter::Abstract.When","name":"When","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"When(.)","arguments":[{"name":"type"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":76,"source":"def self.When(type, &block)\n  #raise ArgumentError unless %w{session demo demonstration step}.include?(type.to_s)\n  #type = :demonstration if type.to_s == 'demo'\n  define_method(type, &block)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract.Before":{"!":"method","declarations":["class","public"],"path":"QED::Reporter::Abstract.Before","name":"Before","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"Before(.)","arguments":[{"name":"type"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":82,"source":"def self.Before(type, &block)\n#  raise ArgumentError unless %w{session demo demonstration step}.include?(type.to_s)\n#  type = :demonstration if type.to_s == 'demo'\n  define_method(\"before_#{type}\", &block)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract.After":{"!":"method","declarations":["class","public"],"path":"QED::Reporter::Abstract.After","name":"After","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"After(.)","arguments":[{"name":"type"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":88,"source":"def self.After(type, &block)\n#  raise ArgumentError unless %w{session demo demonstration step pass fail error}.include?(type.to_s)\n#  type = :demonstration if type.to_s == 'demo'\n  define_method(\"after_#{type}\", &block)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#count_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#count_demo","name":"count_demo","namespace":"QED::Reporter::Abstract","comment":"def After(type, target, *args)\n type = :demonstration if type.to_s == 'demo'\n __send__(\"after_#{type}\", target, *args)\nend","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"count_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":106,"source":"def count_demo(demo)\n  @record[:demo] << demo\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#count_step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#count_step","name":"count_step","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"count_step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":110,"source":"def count_step(step)\n  @record[:step] << step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#count_pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#count_pass","name":"count_pass","namespace":"QED::Reporter::Abstract","comment":"def count_eval(step)\n @record[:eval] << step\nend","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"count_pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":118,"source":"def count_pass(step)\n  @record[:pass] << step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#count_fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#count_fail","name":"count_fail","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"count_fail(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":122,"source":"def count_fail(step, exception)\n  @record[:fail] << [step, exception]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#count_error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#count_error","name":"count_error","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"count_error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":126,"source":"def count_error(step, exception)\n  @record[:error] << [step, exception]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#before_session","name":"before_session","namespace":"QED::Reporter::Abstract","comment":"At the start of a session, before running any demonstrations.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":132,"source":"def before_session(session)\n  @session    = session\n  @start_time = Time.now\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#before_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#before_demo","name":"before_demo","namespace":"QED::Reporter::Abstract","comment":"Beginning of a demonstration.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":138,"source":"def before_demo(demo) #demo(demo)\n  #demos << demo\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#before_step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#before_step","name":"before_step","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":143,"source":"def before_step(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#before_proc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#before_proc","name":"before_proc","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_proc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":147,"source":"def before_proc(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#before_eval":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#before_eval","name":"before_eval","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_eval(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":151,"source":"def before_eval(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#demo","name":"demo","namespace":"QED::Reporter::Abstract","comment":"Reight before demo.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":160,"source":"def demo(demo)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#rule":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#rule","name":"rule","namespace":"QED::Reporter::Abstract","comment":"Right before rule section.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"rule(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":164,"source":"def rule(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#step","name":"step","namespace":"QED::Reporter::Abstract","comment":"Right before text section.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":168,"source":"def step(step)  #show text ?\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#proc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#proc","name":"proc","namespace":"QED::Reporter::Abstract","comment":"Right before evaluation.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"proc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":172,"source":"def proc(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#eval":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#eval","name":"eval","namespace":"QED::Reporter::Abstract","comment":"Right before evaluation.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"eval(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":176,"source":"def eval(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#pass","name":"pass","namespace":"QED::Reporter::Abstract","comment":"After running a step that passed.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":184,"source":"def pass(step)\n  #@pass << step\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#fail","name":"fail","namespace":"QED::Reporter::Abstract","comment":"After running a step that failed.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":189,"source":"def fail(step, assertion)\n  #@fail << [step, assertion]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#error","name":"error","namespace":"QED::Reporter::Abstract","comment":"After running a step that raised an error.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":194,"source":"def error(step, exception)\n  raise exception if $DEBUG  # TODO: do we really want to do it like this?\n  #@error << [step, exception]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#after_eval":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#after_eval","name":"after_eval","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_eval(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":200,"source":"def after_eval(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#after_proc":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#after_proc","name":"after_proc","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_proc(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":204,"source":"def after_proc(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#after_step":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#after_step","name":"after_step","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_step(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":208,"source":"def after_step(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#after_demo":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#after_demo","name":"after_demo","namespace":"QED::Reporter::Abstract","comment":"End of a demonstration.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_demo(demo)","arguments":[{"name":"demo"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":212,"source":"def after_demo(demo)  #demo(demo)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::Abstract#after_session","name":"after_session","namespace":"QED::Reporter::Abstract","comment":"After running all demonstrations. This is the place\nto output a summary of the session, if applicable.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":217,"source":"def after_session(session)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#print_time":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#print_time","name":"print_time","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"print_time()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":222,"source":"def print_time\n  io.puts \"\\nFinished in %.5f seconds.\\n\\n\" % [Time.now - @start_time]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#print_tally":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#print_tally","name":"print_tally","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"print_tally()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":226,"source":"def print_tally\n  #assert_count = AE::Assertor.counts[:total]\n  #assert_fails = AE::Assertor.counts[:fail]\n  #assert_delta = assert_count - assert_fails\n\n  mask = \"%s demos, %s steps: %s failures, %s errors (%s/%s assertions)\"\n  #vars = [demos.size, steps.size, fails.size, errors.size, assert_delta, assert_count] #, @pass.size ]\n\n  io.puts mask % get_tally\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#get_tally":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#get_tally","name":"get_tally","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"get_tally()","arguments":[]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":238,"source":"def get_tally\n  assert_count = AE::Assertor.counts[:total]\n  assert_fails = AE::Assertor.counts[:fail]\n  assert_delta = assert_count - assert_fails\n\n  vars = [demos.size, steps.size, fails.size, errors.size, assert_delta, assert_count] #, @pass.size ]\n\n  vars \nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#sane_backtrace":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#sane_backtrace","name":"sane_backtrace","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"sane_backtrace(exception)","arguments":[{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":252,"source":"def sane_backtrace(exception)\n  if trace_count\n    clean_backtrace(*exception.backtrace[0, trace_count])\n  else\n    clean_backtrace(*exception.backtrace)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#clean_backtrace":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#clean_backtrace","name":"clean_backtrace","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"clean_backtrace(*btrace)","arguments":[{"name":"*btrace"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":261,"source":"def clean_backtrace(*btrace)\n  stack = if $DEBUG\n            btrace\n          else\n            btrace.reject{ |bt| bt =~ INTERNALS }\n          end\n  stack.map do |bt|\n    bt.chomp(\":in \\`__binding__'\")\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#code_snippet":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#code_snippet","name":"code_snippet","namespace":"QED::Reporter::Abstract","comment":"Produce a pretty code snippet given an exception.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"code_snippet(exception, radius=2)","arguments":[{"name":"exception"},{"name":"radius","default":"2"}]}],"returns":[{"type":"String","comment":"pretty code snippet"}],"file":"/lib/qed/reporter/abstract.rb","line":295,"source":"def code_snippet(exception, radius=2)\n  radius = radius.to_i\n\n  file, lineno = file_and_line(exception)\n\n  return nil if file.empty?\n  return nil if file == '(eval)'\n\n  source = source(file)\n  \n  region = [lineno - radius, 1].max ..\n           [lineno + radius, source.length].min\n\n  # ensure proper alignment by zero-padding line numbers\n  format = \" %2s %0#{region.last.to_s.length}d %s\"\n\n  pretty = region.map do |n|\n    format % [('=>' if n == lineno), n, source[n-1].chomp]\n  end #.unshift \"[#{region.inspect}] in #{source_file}\"\n\n  pretty\nend","language":"ruby","dynamic":true,"tags":{"param":"The number of surrounding lines to show."}},"QED::Reporter::Abstract#structured_code_snippet":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#structured_code_snippet","name":"structured_code_snippet","namespace":"QED::Reporter::Abstract","comment":"Return a structure code snippet in an array of lineno=>line \nhash elements.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"structured_code_snippet(exception, radius=2)","arguments":[{"name":"exception"},{"name":"radius","default":"2"}]}],"returns":[{"type":"Hash","comment":"structured code snippet"}],"file":"/lib/qed/reporter/abstract.rb","line":328,"source":"def structured_code_snippet(exception, radius=2)\n  radius = radius.to_i\n\n  file, lineno = file_and_line(exception)\n\n  return {} if file.empty?\n\n  source = source(file)    \n\n  region = [lineno - radius, 1].max ..\n           [lineno + radius, source.length].min\n\n  region.map do |n|\n    {n => source[n-1].chomp}\n  end\nend","language":"ruby","dynamic":true,"tags":{"param":"The number of surrounding lines to show."}},"QED::Reporter::Abstract#source":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#source","name":"source","namespace":"QED::Reporter::Abstract","comment":"Cache the source code of a file.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"source(file)","arguments":[{"name":"file"}]}],"returns":[{"type":"String","comment":"source code"}],"file":"/lib/qed/reporter/abstract.rb","line":350,"source":"def source(file)\n  @source[file] ||= (\n    if File.exist?(file)\n      File.readlines(file)\n    else\n      ''\n    end\n  )\nend","language":"ruby","dynamic":true,"tags":{"param":"full pathname to file"}},"QED::Reporter::Abstract#file_and_line":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#file_and_line","name":"file_and_line","namespace":"QED::Reporter::Abstract","comment":"--\nTODO: Show more of the file name than just the basename.\n++","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file_and_line(exception)","arguments":[{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":366,"source":"def file_and_line(exception)\n  backtrace = case exception\n              when Exception\n                exception.backtrace.reject{ |bt| bt =~ INTERNALS }.first\n              when Array\n                exception.first\n              else\n                exception\n              end\n\n  backtrace =~ /(.+?):(\\d+(?=:|\\z))/ or return \"\"\n\n  file, lineno = $1, $2.to_i\n\n  return file, lineno\n\n  #i = backtrace.rindex(':in')\n  #line = i ? line[0...i] : line\n  #relative_file(line)\nend","language":"ruby","dynamic":true,"tags":{"param":"An exception or backtrace."}},"QED::Reporter::Abstract#file_line":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#file_line","name":"file_line","namespace":"QED::Reporter::Abstract","comment":"Same as file_and_line, exception return file path is relative.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"file_line(exception)","arguments":[{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":388,"source":"def file_line(exception)\n  file, lineno = file_and_line(exception)\n  return relative_file(file), lineno\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#trace_count":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#trace_count","name":"trace_count","namespace":"QED::Reporter::Abstract","comment":"Looks at ENV['trace'] to determine how much trace output to provide.\nIf it is not set, or set to`false` or `off`, then the default trace count\nis used. If set to `0`, `true`, 'on' or 'all' then aa complete trace dump\nis provided. Otherwise the value is converted to an integer and that many\nline of trace is given.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"trace_count()","arguments":[]}],"returns":[{"type":"Integer","comment":"trace count"},{"type":"nil","comment":"trace count"}],"file":"/lib/qed/reporter/abstract.rb","line":405,"source":"def trace_count\n  cnt = ENV['trace']\n  case cnt\n  when nil, 'false', 'off'\n    DEFAULT_TRACE_COUNT\n  when 0, 'all', 'true', 'on'\n    nil\n  else\n    Integer(cnt)\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#relative_file":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#relative_file","name":"relative_file","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"relative_file(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":418,"source":"def relative_file(file)\n  pwd = Dir.pwd\n  idx = (0...pwd.size).find do |i|\n    file[i,1] != pwd[i,1]\n  end\n  idx ||= 1\n  file[(idx-1)..-1]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::Abstract#localize_file":{"!":"method","declarations":["instance","private"],"path":"QED::Reporter::Abstract#localize_file","name":"localize_file","namespace":"QED::Reporter::Abstract","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"localize_file(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/qed/reporter/abstract.rb","line":428,"source":"def localize_file(file)\n  j = 0\n  [file.to_s.size, Dir.pwd.size].max.times do |i|\n    if Dir.pwd[i,1] != file[i,1]\n      break j = i\n    end\n  end\n  file[j..-1]\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::DotProgress":{"!":"class","superclass":"QED::Reporter::Abstract","path":"QED::Reporter::DotProgress","name":"DotProgress","namespace":"QED::Reporter","comment":"= DotProgress Reporter","format":"rdoc","constants":["QED::Reporter::Abstract::INFO_SIGNAL","QED::Reporter::Abstract::INTERNALS","QED::Reporter::Abstract::DEFAULT_TRACE_COUNT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::Reporter::DotProgress#before_session","QED::Reporter::DotProgress#pass","QED::Reporter::DotProgress#fail","QED::Reporter::DotProgress#error","QED::Reporter::DotProgress#after_session"],"accessors":[],"files":["/lib/qed/reporter/dotprogress.rb"],"tags":{}},"QED::Reporter::DotProgress#before_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::DotProgress#before_session","name":"before_session","namespace":"QED::Reporter::DotProgress","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"before_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/dotprogress.rb","line":11,"source":"def before_session(session)\n  @start_time = Time.now\n  io.puts \"Started\"\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::DotProgress#pass":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::DotProgress#pass","name":"pass","namespace":"QED::Reporter::DotProgress","comment":"def before_step(step)\n super(step)\n io.print \".\"\n io.flush\nend","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"pass(step)","arguments":[{"name":"step"}]}],"returns":[],"file":"/lib/qed/reporter/dotprogress.rb","line":23,"source":"def pass(step)\n  io.print \".\"\n  io.flush\n  super(step)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::DotProgress#fail":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::DotProgress#fail","name":"fail","namespace":"QED::Reporter::DotProgress","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"fail(step, assertion)","arguments":[{"name":"step"},{"name":"assertion"}]}],"returns":[],"file":"/lib/qed/reporter/dotprogress.rb","line":29,"source":"def fail(step, assertion)\n  io.print \"F\"\n  io.flush\n  super(step, assertion)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::DotProgress#error":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::DotProgress#error","name":"error","namespace":"QED::Reporter::DotProgress","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"error(step, exception)","arguments":[{"name":"step"},{"name":"exception"}]}],"returns":[],"file":"/lib/qed/reporter/dotprogress.rb","line":35,"source":"def error(step, exception)\n  io.print \"E\"\n  io.flush\n  super(step, exception)\nend","language":"ruby","dynamic":true,"tags":{}},"QED::Reporter::DotProgress#after_session":{"!":"method","declarations":["instance","public"],"path":"QED::Reporter::DotProgress#after_session","name":"after_session","namespace":"QED::Reporter::DotProgress","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"after_session(session)","arguments":[{"name":"session"}]}],"returns":[],"file":"/lib/qed/reporter/dotprogress.rb","line":42,"source":"def after_session(session)\n  print_time\n\n  errors.each do |step, exception|\n    backtrace = sane_backtrace(exception)\n\n    io.puts \"***** ERROR *****\".ansi(:red)\n    io.puts \"#{exception}\"\n    backtrace.each do |bt|\n      io.puts bt\n      io.puts code_snippet(bt)\n    end\n    io.puts\n  end\n\n  fails.each do |step, assertion|\n    backtrace = sane_backtrace(assertion)\n\n    io.puts \"***** FAIL *****\".ansi(:red, :bold)\n    io.puts \"#{assertion}\"\n    backtrace.each do |bt|\n      io.puts bt\n      io.puts code_snippet(bt)\n    end\n    io.puts\n  end\n\n  print_tally\nend","language":"ruby","dynamic":true,"tags":{}},"QED::FileFixtures":{"!":"module","path":"QED::FileFixtures","name":"FileFixtures","namespace":"QED","comment":"This extension provides a simple means for creatind file-system fixtures.\nInclude this in your applique, to have a","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["QED::FileFixtures.included","QED::FileFixtures#copy_fixture"],"accessors":[],"files":["/lib/qed/helpers/file_fixtures.rb"],"tags":{}},"QED::FileFixtures.included":{"!":"method","declarations":["class","public"],"path":"QED::FileFixtures.included","name":"included","namespace":"QED::FileFixtures","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"included(.)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/qed/helpers/file_fixtures.rb","line":8,"source":"def self.included(base)\n  require 'erb'\nend","language":"ruby","dynamic":true,"tags":{"private":null}},"QED::FileFixtures#copy_fixture":{"!":"method","declarations":["instance","public"],"path":"QED::FileFixtures#copy_fixture","name":"copy_fixture","namespace":"QED::FileFixtures","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"copy_fixture(name, tmpdir=nil)","arguments":[{"name":"name"},{"name":"tmpdir","default":"nil"}]}],"returns":[],"file":"/lib/qed/helpers/file_fixtures.rb","line":13,"source":"def copy_fixture(name, tmpdir=nil)\n  tmpdir ||= 'tmp' # self.tmpdir\n  FileUtils.mkdir(tmpdir) unless File.directory?(tmpdir)\n  srcdir = File.join(demo_directory, 'fixtures', name)\n  paths  = Dir.glob(File.join(srcdir, '**', '*'), File::FNM_DOTMATCH)\n  paths.each do |path|\n    basename = File.basename(path)\n    next if basename == '.'\n    next if basename == '..'\n    dest = File.join(tmpdir, path.sub(srcdir+'/', ''))\n    if File.directory?(path)\n      FileUtils.mkdir(dest)\n    else\n      text = ERB.new(File.read(path)).result\n      File.open(dest, 'w'){ |f| f << text }\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":"2011-10-24 00:21:00 -0400","text":"= Ruby Q.E.D.\n\n\n== Introduction\n\nQ.E.D. is an abbreviation for the well known Latin phrase \"Quod Erat Demonstrandum\",\nliterally \"which was to be demonstrated\", which is oft written in its abbreviated\nform at the end of a mathematical proof or philosophical argument to signify\na successful conclusion. And so it is too for Ruby Q.E.D., though it might as easily\nbe taken to stand for \"Quality Ensured Documentation\". \n\nQED is in fact both a test framework and a documentation system for Ruby\ndevelopers. QED sits somewhere between lower-level testing tools like Test::Unit\nand grandiose requirement specifications systems like Cucumber. In practice it\nworks exceptionally well for <i>API-Driven Design</i>, which is especially\nuseful when designing reusable libraries, but it can be used to test code at\nany level of abstraction, from unit test to systems tests.\n\n\n== Features\n\n* Write tests and documentation in the same breath!\n* Demos can be RDoc, Markdown or any other conforming text format.\n* Uses the excellent AE (Assertive Expressive) library for assertions.\n* Table macro allows large sets of data to be tested by the same code.\n* Documentation tool provides nice output with jQuery-based TOC.\n\n\n== Resources\n\n* {Homepage}[http://rubyworks.github.com/qed]\n* {Mailing list}[http://groups.google.com/group/rubyworks-mailinglist]\n* {Development}[http://github.com/rubyworks/qed]\n\n\n== Synopsis\n\n=== Assertion Syntax\n\nQED uses the AE (Assertive Expressive) library to provide an elegant means to\nmake assertions. To give a quick overview, assertion can be written as:\n\n    4.assert == 5\n\nIn this example, because 4 != 5, this expression will raise an Assertion\nexception. QED's Runner class is thus just a means of running and capturing\ncode blocks containing these assertions.\n\nYou can learn more about AE at http://rubyworks.github.com/ae.\n\n=== Document Structure\n\nQED documents are simply text files called *demonstrandum*. Because they \nlargely consist of free-form descriptive text, they are a practice pure \nLiterate Programming. For example:\n\n    = Example\n\n    Shows that the number 5 does not equal 4.\n\n        5.assert! == 4\n\n    But in fact equals 5.\n\n        5.assert == 5\n\nIn this example RDoc was chosen for the document format. However, almost any\ntext format can be used. The only necessary distinction is that description text\nalign to the left margin and all code be indented, although QED does recognize\nRDoc and Markdown single-line style headers, so any format that supports\nthose (which covers many markup formats in use today) will have mildly\nimproved console output. In any case, the essential take away here is that\nQED *demonstrandum* are simply descriptive documents with interspersed \nblocks of example code.\n\nGive this design some thought. It should become clear that this approach is\nespecially fruitful in that it allows *documentation* and *specification*\nto seamlessly merge into a unified *demonstration*. \n\n=== Running Demonstrations\n\nIf we were to run the above document through QED in verbatim mode the output\nwould be identical (assuming we did not make a typo and the assertions passed).\nIf there were errors or failures, we would see information detailing each.\n\nTo run a document through QED, simply use the +qed+ command.\n\n  $ qed -v demo/01_example.rdoc\n\nThe <code>-v</code> option specifies verbatim mode, which outputs the entire\ndocument.\n\nNotice we placed the QED document in a <code>demo/</code> directory, this is no\nstandard place that demonstrations have to go. They can be placed anywhere\nin a project that is preferred (lately I've been use qed/). Also notice the\n`<code>01_</code>` prefix in front of the name. While this is not strictly\nnecessary, it helps order the documents nicely in particular when generating\nQED documentation (\"QEDocs\").\n\n=== Utilizing Applique\n\nQED demonstrandum descriptive text is not strictly passive explanation. Using\npattern matching techniques, document phrases can trigger underlying actions.\nThese actions provide a support structure for running tests called the *applique*.\n\nCreating an applique is easy. Along with your QED scripts, to which the \napplique will apply, create an <code>applique/</code> directory. In this\ndirectory add Ruby scripts. When you run your demos every Ruby script in \nthe directory will be automatically loaded.\n\nWithin these applique scripts *advice* can be defined. Advice can be\neither *event advice*, which is simply triggered by some fixed cycle\nof running, such as <code>Before :each</code> or <code>After :all</code>,\nand *pattern advice* which are used to match against descriptive\nphrases in the QED demos. An example would be:\n\n  When \"a new round is started\" do\n    @round = []\n  end\n\nSo that whenever the phrase \"a new round is started\" appears in a demo,\nthe @round instance variable with be reset to an empty array.\n\nIt is rather amazing what can be accomplished with such a system,\nbe sure to look at QED's own demonstrandum to get a better notion of\nhow you can put the the system to use.\n\n=== Generating Documentation\n\nTo generate documentation from QED documents, use the +qedoc+ command.\n\n  $ qedoc --output doc/qedoc --title \"Example\" demo/*.rdoc\n\nWhen documenting, QED recognizes the format by the file extension and \ntreats it accordingly. An extension of <code>.qed</code> is treated the same\nas <code>.rdoc</code>.\n\nUse the <code>--help</code> options on each command to get more information\non the use of these commands.\n\n\n== Requirements\n\nQED depends on the following external libraries:\n\n  * AE     - Assertions Framework\n  * ANSI   - ANSI Color Codes\n  * Facets - Core Extensions\n\nThese will be automatically installed when installing QED via RubyGems,\nif they are not already installed.\n\n\n== Copyright and License\n\nQ.E.D.\n\nCopyright (c) 2007 Thomas Sawyer\n\nBSD 2 Clause License\n\nSee LICENSE.rdoc for details.\n","format":"text/rdoc"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":"2011-11-18 14:06:47 -0500","text":"= RELEASE HISTORY\n\n== 2.7.0 | 2011-11-18\n\nWith this release the underlying evaluator API has a much better design\nIn most respects the changes will not effect older QED documents. In \naddition to this, a new notation for captures has been added. With it,\ncaptures can now be written as `/(\\S+)/` and non-capture expressions\nas `/?:\\S+/`. The old parenthetical notation still works. This release\nalso entails a few other changes. See the change list below for details.\n\nChanges:\n\n* Deprecate use of '...' as a plain text example indicator.\n* When string arguments can use '...' to split the match.\n* Applique files can now be demo documents too.\n* Use confection gem for configuration.\n* Must use `-f` option to use (most) alternative reporters.\n* Show full backtrace in (most) reporters.\n* Overhaul evaluator using better signal names.\n* Underlying observer API redesigned (effects reporters).\n\n\n== 2.6.3 | 2011-10-23\n\nFixed output status. When tests fail or error the `qed`\ncommand with exit -1 instead to 0. Also, the default\nspec location uses only one of `qed`, `demo` or `spec`\ninstead of all.\n\nChanges:\n\n* Fix output status, exit -1 on test failure or error.\n* Fix default spec location to only use one or the other.\n\n\n== 2.6.1 | 2011-07-02\n\nA friend suggested QED default the load path to lib and\nautomatically look for QED demos in default locations\n(qed, demo, spec) if no files are passed to it on the\ncommand line. So it is.\n\nChanges:\n\n* Default loadpath option to lib/.\n* Default files to markup files in spec/, demo/ and qed/.\n* Fix website links (you might actually find things now).\n\n\n== 2.6.0 | 2011-07-01\n\nThis release fixes some issues with reporters, further refines\ntheir output and adds the start of a new reporter called dtrace.\nAlso the Table and Data macros have been updated. Table can now\nhandle a YAML stream with the :stream option, and Data no long runs\nthe text through YAML.load when the file name ends in .yml or .yaml,\nIn other words it's for raw fixture data. Finally the documentation\ntool has been improved to simplify HTML generation and also add a\nformat option for creating a simple plain text merging instead.\n\nChanges:\n\n* Data is raw and no longer uses YAML.load.\n* Table can handle a YAML stream, via :stream option.\n* Better handling of code snippets.\n* Backtrace count defaults to 2 rather than 3.\n* Load ansi/core, rather than ansi/code.\n* Doc output setting takes a file name instead of directory.\n* Support for plain text format (by simple file merge).\n* HTML output is single file, jquery comes from CDNJ.\n\n\n== 2.5.2 | 2011-06-26\n\nThis release focuses on reporter improvements. Better trace\ninformation is now displayed, and the max number of backtrace\nlines can be set with the -t option, or $trace environment\nvariable.\n\nChanges:\n\n* Trace option takes a max count setting (0 for all).\n* Trace count can also be set via $trace environment variable.\n* Added TAP-Y reporter.\n\n\n== 2.5.1 | 2011-06-07\n\nThis release makes a number adjustments and fixes one major issue\nwith the way the latest AE library counts assertions.\n\nChanges:\n\n* Fix references to AE assertion counts.\n* @_ stores the return value of last execution block.\n* Backtrace filter omits references to AE library.\n\n\n== 2.5.0 | 2010-11-04\n\nThe latest release of QED improves on applique loading, such that each\ndemonstrandum gets it's own localized set. The CLI has also been modified\nso that there is no longer a default location, the directory or files to run\nmust be specified.\n\nChanges:\n\n* Better handling of Applique.\n* Remove Advice class --advice is now stored in Applique.\n* Each applique file is it's own module.\n* Advice from each applique is applied.\n* CLI requires files be specified.\n\n\n== 2.4.0 | 2010-09-02\n\nAll engines go! QED has not been tested against 1.8.6, 1.8.7 and 1.9.2.\nUnderthehood steps are not organized in doubly-linked lists, which makes\nthem much more robust and flexible. This release also improves scoping,\ntest counts, and inline documentation parsing.\n\nChanges:\n\n* Use new doubly-linked list step design.\n* Fix -r option on command line.\n* Provide #instance_exec core extension for Ruby 1.8.6.\n* Scope is extended by and includes applique.\n\n\n== 2.3.0 | 2010-07-14\n\nBug to the scurry! QED has broken through the code/document ceiling and\nis cracking exoskeletons all the way to the bank. A proverbial can of\nRoach-Be-Gone this is! What's that you say? I will explain. QED can now\nrun directly against code comments. Simply slip the qed command the -c\noption and feed it some ruby scripts, and presto watch you comments\nfail ;) I think you can figure out what to do next.\n\nIn addition to this coolness QED has been improved under the floor\nboards as well. The parser, which is much faster, now blocks commentary\nparagraphs and code examples together in one-to-one pairings. Not only\ndoes this clean-up the code, but it opens up the potential for Around\nadvice in a future version.\n\nChanges:\n\n* NEW! Ruby script comment run mode.\n* Better parsing system uses commentary-example pairs.\n* Colon can also be used to specify plain text (along with ellipsis).\n* Now distributed under the more permissive Apache 2.0 license.\n\n\n== 2.2.2 | 2010-06-21\n\nAn issue was reported in which the a code block at the very\ntop of a demo was being ignored. This release fixes this issue\nby rewriting the parser (much better now thanks!). At the same\ntime the Data and Table methods have been polished, both of\nwhich can now pick up sample data relative to the current demo.\n\nChanges:\n\n* Rewrite parser and fix top code issue.\n* Data method cannot write data, instead executes block.\n* Data and Table methods look for file relative to demo first.\n* Added -R option to run demos relative to project root.\n\n\n== 2.2.1 | 2010-06-20\n\nRemove dependencies to Tilt and Nokogiri. Should have\ndone this in last release but alas --there is so\nmuch to do.\n\nChanges:\n\n* Removed HTML parsing dependencies.\n* Reduce Advice to a single class.\n\n\n== 2.2.0 | 2010-06-19\n\nThis release returns to a text-based evaluator, rather\nthen use HTML. Processing HTML proved to have too many\nedge cases to be effective --both in implementation\nand in end-usage. So to remedy the situation QED has\nreturn to supporting simple markup formats such as\nRDoc and Markup.\n\nThis release also adds multi-pattern advice. Instead of\na single pattern, multiple patterns can be matched\nsequentially. This make it a easier to match large text\ndescriptions without restoring to regular expressions.\n\nIn addition QED now supports raw text blocks. By ending\na description section in ellipsis (...), the subsequent\ncode section becomes a plain text section and is passed\ninto the argument list of any matching When advice. This\nmakes it easy to scaffold fixture files, for example.\n\nFinally, this release also refines the evaluation scopes.\nWhere before, a new binding was being created, each was \nattached to the TOPLEVEL, and therefore not truly isolated \non a per-document basis. To correct, QED now mocks the\nTOPLEVEL providing a new instance of this mock object for\neach document.\n\nChanges:\n\n* No longer uses HTML for document processing.\n* Support for plain text blocks using ellipsis.\n* New sequential multi-pattern matches.\n* Mock TOPLEVEL at both the demo and applique levels.\n* Adjust color support for latest ANSI release.\n\n\n== 2.1.1 | 2010-04-08\n\nFixed bug introduced in the last version that executed all\nscripts in a single binding. There needed to be a binding\nfor each script.\n\nChanges:\n\n* Fixed cross-script bug by moving binding instantiation into Script class.\n\n\n== 2.1.0 | 2010-04-07\n\nQED documents are now run in the TOPLEVEL context, rather\nthan in a subclass of Scope. This ensures code runs as\none would expect it too in the wild.\n\nChanges:\n\n* Scope.new redirect to TOPLEVEL.\n* DomainLanguage module is added to include into TOPLEVEL.\n\n\n== 2.0.0 | 2010-03-04\n\nThis is a major new release of QED. All demonstration documents\nare now converted to HTML via Tilt (http://github.com/tilt) before\nbeing run through the test runner. So QED now supports any markup\nformat supported by Tilt, as well as ordinary HTML. Simply\nstated, QED process <tt>pre</tt> tags as code and everything else\nas comments. Nokogiri is used to parse the HTML.\n\nChanges:\n\n* HTML serves as a common format.\n* New dependencies: Tilt and Nokogiri.\n* New system of version numbers.\n\n\n== 1.2.0 | 2009-12-07\n\nThis release adds a significant new feature, Comment Matchers.\nThese work like Cucumber allowing for background code to\nbe run when matching comments occur --a much better solution\nfor setup and teardown.\n\nChanges:\n\n* 2 Major Enhancements\n\n  * Added command matchers via #When method.\n  * All QED methods are now capitalized.\n\n* 2 Minor Enhancements\n\n  * Use OptionParser for qed executable.\n  * Verbatim reporter is literally verbatim.\n\n\n== 1.1.1 | 2009-09-05\n\nThis release \n\nChanges:\n\n* 2 Major Enhancements\n\n  * Helpers are provided by bottom code.\n  * Added Markdown header support.\n\n* 2 Minor Enhancements\n\n  * Use Ansi project for color output.\n  * Use latest RDoc version.\n\n\n== 1.0.0 | 2009-06-30\n\nQED has found itself. It took some time to really figure out\nwhat this project \"was\" and how it should best be utilized.\nThis release is the initial release that puts QED in proper\nperspective.\n\nChanges:\n\n* 2 Major Enhancement\n\n    * Partial rewrite of a project that was once called \"Quarry\".\n    * Now use AE for assertions.\n\n","format":"text/rdoc"},"/COPYING.rdoc":{"!":"document","path":"COPYING.rdoc","name":"COPYING.rdoc","mtime":"2011-11-17 20:26:12 -0500","text":"= COPYRIGHT NOTICES\n\n== QED\n\nCopyright:: (c) 2007 Rubyworks, Thomas Sawyer\nLicense:: BSD-2-Clause\nWebsite:: http://rubyworks.github.com/qed\n\n    Copyright 2007 Rubyworks. All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY Thomas Sawyer ``AS IS'' AND ANY EXPRESS\n    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\n    NO EVENT SHALL Thomas Sawyer OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n","format":"text/rdoc"},"/lib/qed.yml":{"!":"document","path":"lib/qed.yml","name":"qed.yml","mtime":"2011-11-19 19:17:18 -0500","text":"---\nsource:\n- var\nsource_url: http://raw.github.com/rubyworks/qed/master\nauthors:\n- name: Trans\n  email: transfire@gmail.com\ncopyrights:\n- holder: Thomas Sawyer, Rubyworks\n  year: '2006'\n  license: BSD-2-Clause\nreplacements: []\nalternatives: []\nrequirements:\n- name: ansi\n- name: facets\n  version: 2.8+\n- name: ae\n  version: 1.7+\n- name: confection\n- name: detroit\n  groups:\n  - build\n  development: true\ndependencies: []\nconflicts: []\nrepositories:\n- uri: git://github.com/rubyworks/qed.git\n  scm: git\n  name: upstream\nresources:\n  home: http://rubyworks.github.com/qed\n  code: http://github.com/rubyworks/qed\n  mail: http://groups.google.com/groups/rubyworks-mailinglist\n  bugs: http://github.com/rubyworks/qed/issues\nextra: {}\nload_path:\n- lib\nrevision: 0\ncreated: '2006-12-16'\nsummary: Quod Erat Demonstrandum\ntitle: QED\nversion: 2.7.0\nname: qed\ndescription: ! 'QED (Quality Ensured Demonstrations) is a TDD/BDD framework\n\n  utilizing Literate Programming techniques.'\ndate: '2011-11-18'\n","format":"text/plain"},"/lib/qed.rb":{"!":"script","path":"lib/qed.rb","name":"qed.rb","mtime":"2011-11-16 18:56:41 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed.rb","language":"text/x-ruby"},"/lib/qed/document/template.rhtml":{"!":"document","path":"lib/qed/document/template.rhtml","name":"template.rhtml","mtime":"2011-07-06 07:40:40 -0400","text":"<html>\n<head>\n  <title><%= title %></title>\n\n  <!-- TODO: most of the css before the '*' can be removed. -->\n\n  <style>\n    #container{ margin: 0 auto; width: 800px; }\n\n    /* Debug borders */\n    /* p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 { border: 1px solid red; } */\n\n    body { font-size: 14px; line-height: 20px; margin: 1em 5% 1em 5%; font-family: Verdana, Arial, Helvetica, sans-serif; }\n    a { color: #336; text-decoration: underline; }\n    a:visited { color: #334; }\n    em { font-style: italic; }\n    strong { font-weight: bold; }\n    tt { color: navy; }\n\n    h1, h2, h3, h4, h5, h6 { color: #223; margin-top: 1.2em; margin-bottom: 0.5em; line-height: 1.3; }\n    h1 { border-bottom: 2px solid silver; }\n    h2 { border-bottom: 2px solid silver; padding-top: 0.5em; }\n\n    hr { color: #ccc; margin-top: 1.6em; }\n\n    p { color: #222; text-align: justify; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.4em; }\n\n    /* pre { padding: 10; margin: 0; font-family: monospace; font-size: 0.9em; } */\n\n    pre.pass { color: green; }\n    pre.fail { color: red; }\n    pre.error { color: red; font-weight: bold; }\n\n    span#author { color: #527bbd; font-weight: bold; font-size: 1.1em; }\n    span#email { }\n    span#revision { }\n\n    div#footer { font-size: small; border-top: 2px solid silver; padding-top: 0.5em; margin-top: 4.0em; }\n    div#footer-text { float: left; padding-bottom: 0.5em; }\n    div#footer-badges { float: right; padding-bottom: 0.5em; }\n\n    /* Block element content. */\n    div.content { padding: 0; }\n\n    /* Block element titles. */\n    h1.title { font-weight: bold; text-align: left; font-size: 3em; margin-top: 1.0em; margin-bottom: 0.5em; }\n\n    /* Block element titles. */\n    div.title, caption.title { font-weight: bold; text-align: left; margin-top: 1.0em; margin-bottom: 0.5em; }\n    div.title + * { margin-top: 0; }\n    td div.title:first-child { margin-top: 0.0em; }\n    div.content div.title:first-child { margin-top: 0.0em; }\n    div.content + div.title { margin-top: 0.0em; }\n    div.sidebarblock > div.content { background: #ffffee; border: 1px solid silver; padding: 0.5em; }\n\n    img { border-style: none; }\n\n    dl { margin-top: 0.8em; margin-bottom: 0.8em; }\n    dt { margin-top: 0.5em; margin-bottom: 0; font-style: italic; }\n    dd > *:first-child { margin-top: 0; }\n    ul, ol { list-style-position: outside; }\n\n    thead { font-weight: bold; }\n    tfoot { font-weight: bold; }\n\n    *{margin:0;padding:0;}\n    html,body{height:100%;color:black;}\n    body{background-color:white;font:13.34px helvetica,arial,freesans,clean,sans-serif;*font-size:small;}\n    table{font-size:inherit;font:100%;}\n    select,input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}\n    select,option{padding:0 .25em;}\n    optgroup{margin-top:.5em;}\n    input.text{padding:1px 0;}\n    pre,code{font:12px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;}\n    body *{line-height:1.4em;}\n    p{margin:1em 0;}\n    img{border:0;}\n    abbr{border-bottom:none;}\n\n    .wikistyle h1,.wikistyle h2,.wikistyle h3,.wikistyle h4,.wikistyle h5,.wikistyle h6{border:0!important;}\n    .wikistyle h1{font-size:170%!important;border-top:4px solid #aaa!important;padding-top:.5em!important;margin-top:1.5em!important;}\n    .wikistyle h1:first-child{margin-top:0!important;padding-top:.25em!important;border-top:none!important;}\n    .wikistyle h2{font-size:150%!important;margin-top:1.5em!important;border-top:4px solid #e0e0e0!important;padding-top:.5em!important;}\n    .wikistyle h3{margin-top:1em!important;}\n    .wikistyle p{margin:1em 0!important;line-height:1.5em!important;}\n    .wikistyle ul{margin:1em 0 1em 2em!important;}\n    .wikistyle ol{margin:1em 0 1em 2em!important;}\n    .wikistyle ul ul,.wikistyle ul ol,.wikistyle ol ol,.wikistyle ol ul{margin-top:0!important;margin-bottom:0!important;}\n    .wikistyle blockquote{margin:1em 0!important;border-left:5px solid #ddd!important;padding-left:.6em!important;color:#555!important;}\n    .wikistyle dt{font-weight:bold!important;margin-left:1em!important;}\n    .wikistyle dd{margin-left:2em!important;margin-bottom:1em!important;}\n    .wikistyle table{margin:1em 0!important;}\n    .wikistyle table th{border-bottom:1px solid #bbb!important;padding:.2em 1em!important;}\n    .wikistyle table td{border-bottom:1px solid #ddd!important;padding:.2em 1em!important;}\n    .wikistyle pre{margin:1em 0!important;font-size:90%!important;background-color:#f8f8ff!important;border:1px solid #dedede!important;padding:.5em!important;line-height:1.5em!important;color:#444!important;overflow:auto!important;}\n    .wikistyle pre code{padding:0!important;font-size:100%!important;background-color:#f8f8ff!important;border:none!important;}\n    .wikistyle code{font-size:90%!important;background-color:#f8f8ff!important;color:#444!important;padding:0 .2em!important;border:1px solid #dedede!important;}\n    .wikistyle pre.console{margin:1em 0!important;font-size:90%!important;background-color:black!important;padding:.5em!important;line-height:1.5em!important;color:white!important;}\n    .wikistyle pre.console code{padding:0!important;font-size:100%!important;background-color:black!important;border:none!important;color:white!important;}\n    .wikistyle pre.console span{color:#888!important;}\n    .wikistyle pre.console span.command{color:yellow!important;}\n\n    .title { font-size: 2em; }\n  </style>\n\n  <% if css %>\n  <link rel=\"stylesheet\" href=\"<%= css %>\" type=\"text/css\">\n  <% end %>\n\n  <!-- JQuery is needed -->\n  <script src=\"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.6.1/jquery.min.js\" type=\"text/javascript\" language=\"javascript\"></script>\n\n</head>\n\n<body class=\"wikistyle\">\n\n  <!-- Side Table of Contents -->\n  <div id=\"sidebar\" style=\"position: fixed; top: 10; right: 10; background: white;\">\n    <a href=\"javascript: toc_toggle();\">\n      <!-- TODO: find a preminatn image on web to use -->\n      <!-- <img src=\"http://www.cdnjs.com/images/poweredbycloudflare.png\" style=\"border: none;\" alt=\"TOC\" align=\"right\"/> -->\n    </a>\n\n    <div id=\"toc_side\" class=\"toc\">\n    </div>\n  </div>\n\n  <div id=\"container\">\n    <div id=\"header\">\n      <!-- TODO: find a preminatn image on web to use -->\n      <!-- <img src=\"http://www.cdnjs.com/images/poweredbycloudflare.png\" align=\"left\" style=\"padding-right: 10px;\" alt=\"\"/> -->\n\n      <div class=\"title\"><%= title %></div>\n\n      <h1>Table of Contents</h1>\n\n      <div class=\"toc\">\n      </div>\n    </div>\n\n    <div id=\"content\">\n      <%= spec %>\n    </div>\n  </div>\n\n  <br/><br/><br/>\n</body>\n\n</html>\n\n<script src=\"../assets/scripts/spec.js\" type=\"text/javascript\" language=\"javascript\"></script>\n\n<script type=\"text/javascript\" language=\"javascript\">\n  /*****************************************************************\n   * $.toc()\n   * by rebecca murphey\n   * rmurphey gmail com\n   *\n   * This function is called on its own and takes as an argument\n   * a list of selectors with which it will build a table of\n   * contents. \n   *\n   * The first selector will make up the top level of the TOC;\n   * the second selector will make up the second level of the TOC;\n   * etc.\n   *\n   * This function returns a div containing nested unordered lists;\n   * each list item is linked to an anchor tag added before the item\n   * on the page.\n   *\n   * usage: $.toc('h1,h2,h3').prependTo('body');\n   ************************************************************************/\n  (function($) { \n    $.toc = function(tocList) {\n      $(tocList).addClass('jquery-toc');\n      var tocListArray = tocList.split(',');\n      $.each(tocListArray, function(i,v) { tocListArray[i] = $.trim(v); });\n      var $elements = $('.jquery-toc');\n      $('body').append('<div></div>');\n      var $toc = $('body div:last');\n      var lastLevel = 1;\n      $toc.append('<ul class=\"jquery-toc-1\"></ul>');\n      $elements.each(function() {\n        var $e = $(this);\n        var text = $e.text();\n        var anchor = text.replace(/ /g,'-');\n        $e.before('<a name=\"' + anchor + '\"></a>');\n        var level;\n        $.each(tocListArray, function(i,v) { \n          if (v.match(' ')) {\n            var vArray = v.split(' '); \n            var e = vArray[vArray.length - 1];\n          } else { e = v; }\n          if ($e.is(e)) { level = i+1; } \n        });\n        var className = 'jquery-toc-' + level;\n        var li = '<li><a href=\"#' + anchor + '\">' + text + '</a></li>';\n        if (level == lastLevel) {\n          $('ul.' + className + ':last',$toc).append(li);\n        } else if (level > lastLevel) {\n          var parentLevel = level - 1;\n          var parentClassName = 'jquery-toc-' + parentLevel;\n          $('ul.' + parentClassName + ':last',$toc).\n            append('<ul class=\"' + className + '\"></ul>');\n          $('ul.' + className + ':last',$toc).append(li);\n        } else if (level < lastLevel) {\n          $('ul.' + className + ':last',$toc).append(li);\n        }\n        lastLevel = level;\n      });\n      var $toc_ul = $('ul.jquery-toc-1',$toc);\n      $toc.remove();\n      return($toc_ul);\n   }\n  })(jQuery);\n</script>\n\n<script>\n  function toc_toggle() {\n    $('#toc_side').toggle();\n    $(\"pre\").addClass(\"pass\");\n    $(\"pre:contains('FAIL:')\").addClass(\"fail\");\n    $(\"pre:contains('ERROR:')\").addClass(\"error\");\n  };\n\n  $.toc('#content h1,h2,h3,h4').appendTo('.toc');\n\n  toc_toggle();\n</script>\n\n","format":"text/plain"},"/lib/qed/document/markup.rb":{"!":"script","path":"lib/qed/document/markup.rb","name":"markup.rb","mtime":"2010-09-06 22:27:33 -0400","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/document/markup.rb","language":"text/x-ruby"},"/lib/qed/document/jquery.js":{"!":"document","path":"lib/qed/document/jquery.js","name":"jquery.js","mtime":"2010-06-01 16:12:35 -0400","text":"/*\n * jQuery JavaScript Library v1.3.2\n * http://jquery.com/\n *\n * Copyright (c) 2009 John Resig\n * Dual licensed under the MIT and GPL licenses.\n * http://docs.jquery.com/License\n *\n * Date: 2009-02-19 17:34:21 -0500 (Thu, 19 Feb 2009)\n * Revision: 6246\n */\n(function(){var l=this,g,y=l.jQuery,p=l.$,o=l.jQuery=l.$=function(E,F){return new o.fn.init(E,F)},D=/^[^<]*(<(.|\\s)+>)[^>]*$|^#([\\w-]+)$/,f=/^.[^:#\\[\\.,]*$/;o.fn=o.prototype={init:function(E,H){E=E||document;if(E.nodeType){this[0]=E;this.length=1;this.context=E;return this}if(typeof E===\"string\"){var G=D.exec(E);if(G&&(G[1]||!H)){if(G[1]){E=o.clean([G[1]],H)}else{var I=document.getElementById(G[3]);if(I&&I.id!=G[3]){return o().find(E)}var F=o(I||[]);F.context=document;F.selector=E;return F}}else{return o(H).find(E)}}else{if(o.isFunction(E)){return o(document).ready(E)}}if(E.selector&&E.context){this.selector=E.selector;this.context=E.context}return this.setArray(o.isArray(E)?E:o.makeArray(E))},selector:\"\",jquery:\"1.3.2\",size:function(){return this.length},get:function(E){return E===g?Array.prototype.slice.call(this):this[E]},pushStack:function(F,H,E){var G=o(F);G.prevObject=this;G.context=this.context;if(H===\"find\"){G.selector=this.selector+(this.selector?\" \":\"\")+E}else{if(H){G.selector=this.selector+\".\"+H+\"(\"+E+\")\"}}return G},setArray:function(E){this.length=0;Array.prototype.push.apply(this,E);return this},each:function(F,E){return o.each(this,F,E)},index:function(E){return o.inArray(E&&E.jquery?E[0]:E,this)},attr:function(F,H,G){var E=F;if(typeof F===\"string\"){if(H===g){return this[0]&&o[G||\"attr\"](this[0],F)}else{E={};E[F]=H}}return this.each(function(I){for(F in E){o.attr(G?this.style:this,F,o.prop(this,E[F],G,I,F))}})},css:function(E,F){if((E==\"width\"||E==\"height\")&&parseFloat(F)<0){F=g}return this.attr(E,F,\"curCSS\")},text:function(F){if(typeof F!==\"object\"&&F!=null){return this.empty().append((this[0]&&this[0].ownerDocument||document).createTextNode(F))}var E=\"\";o.each(F||this,function(){o.each(this.childNodes,function(){if(this.nodeType!=8){E+=this.nodeType!=1?this.nodeValue:o.fn.text([this])}})});return E},wrapAll:function(E){if(this[0]){var F=o(E,this[0].ownerDocument).clone();if(this[0].parentNode){F.insertBefore(this[0])}F.map(function(){var G=this;while(G.firstChild){G=G.firstChild}return G}).append(this)}return this},wrapInner:function(E){return this.each(function(){o(this).contents().wrapAll(E)})},wrap:function(E){return this.each(function(){o(this).wrapAll(E)})},append:function(){return this.domManip(arguments,true,function(E){if(this.nodeType==1){this.appendChild(E)}})},prepend:function(){return this.domManip(arguments,true,function(E){if(this.nodeType==1){this.insertBefore(E,this.firstChild)}})},before:function(){return this.domManip(arguments,false,function(E){this.parentNode.insertBefore(E,this)})},after:function(){return this.domManip(arguments,false,function(E){this.parentNode.insertBefore(E,this.nextSibling)})},end:function(){return this.prevObject||o([])},push:[].push,sort:[].sort,splice:[].splice,find:function(E){if(this.length===1){var F=this.pushStack([],\"find\",E);F.length=0;o.find(E,this[0],F);return F}else{return this.pushStack(o.unique(o.map(this,function(G){return o.find(E,G)})),\"find\",E)}},clone:function(G){var E=this.map(function(){if(!o.support.noCloneEvent&&!o.isXMLDoc(this)){var I=this.outerHTML;if(!I){var J=this.ownerDocument.createElement(\"div\");J.appendChild(this.cloneNode(true));I=J.innerHTML}return o.clean([I.replace(/ jQuery\\d+=\"(?:\\d+|null)\"/g,\"\").replace(/^\\s*/,\"\")])[0]}else{return this.cloneNode(true)}});if(G===true){var H=this.find(\"*\").andSelf(),F=0;E.find(\"*\").andSelf().each(function(){if(this.nodeName!==H[F].nodeName){return}var I=o.data(H[F],\"events\");for(var K in I){for(var J in I[K]){o.event.add(this,K,I[K][J],I[K][J].data)}}F++})}return E},filter:function(E){return this.pushStack(o.isFunction(E)&&o.grep(this,function(G,F){return E.call(G,F)})||o.multiFilter(E,o.grep(this,function(F){return F.nodeType===1})),\"filter\",E)},closest:function(E){var G=o.expr.match.POS.test(E)?o(E):null,F=0;return this.map(function(){var H=this;while(H&&H.ownerDocument){if(G?G.index(H)>-1:o(H).is(E)){o.data(H,\"closest\",F);return H}H=H.parentNode;F++}})},not:function(E){if(typeof E===\"string\"){if(f.test(E)){return this.pushStack(o.multiFilter(E,this,true),\"not\",E)}else{E=o.multiFilter(E,this)}}var F=E.length&&E[E.length-1]!==g&&!E.nodeType;return this.filter(function(){return F?o.inArray(this,E)<0:this!=E})},add:function(E){return this.pushStack(o.unique(o.merge(this.get(),typeof E===\"string\"?o(E):o.makeArray(E))))},is:function(E){return !!E&&o.multiFilter(E,this).length>0},hasClass:function(E){return !!E&&this.is(\".\"+E)},val:function(K){if(K===g){var E=this[0];if(E){if(o.nodeName(E,\"option\")){return(E.attributes.value||{}).specified?E.value:E.text}if(o.nodeName(E,\"select\")){var I=E.selectedIndex,L=[],M=E.options,H=E.type==\"select-one\";if(I<0){return null}for(var F=H?I:0,J=H?I+1:M.length;F<J;F++){var G=M[F];if(G.selected){K=o(G).val();if(H){return K}L.push(K)}}return L}return(E.value||\"\").replace(/\\r/g,\"\")}return g}if(typeof K===\"number\"){K+=\"\"}return this.each(function(){if(this.nodeType!=1){return}if(o.isArray(K)&&/radio|checkbox/.test(this.type)){this.checked=(o.inArray(this.value,K)>=0||o.inArray(this.name,K)>=0)}else{if(o.nodeName(this,\"select\")){var N=o.makeArray(K);o(\"option\",this).each(function(){this.selected=(o.inArray(this.value,N)>=0||o.inArray(this.text,N)>=0)});if(!N.length){this.selectedIndex=-1}}else{this.value=K}}})},html:function(E){return E===g?(this[0]?this[0].innerHTML.replace(/ jQuery\\d+=\"(?:\\d+|null)\"/g,\"\"):null):this.empty().append(E)},replaceWith:function(E){return this.after(E).remove()},eq:function(E){return this.slice(E,+E+1)},slice:function(){return this.pushStack(Array.prototype.slice.apply(this,arguments),\"slice\",Array.prototype.slice.call(arguments).join(\",\"))},map:function(E){return this.pushStack(o.map(this,function(G,F){return E.call(G,F,G)}))},andSelf:function(){return this.add(this.prevObject)},domManip:function(J,M,L){if(this[0]){var I=(this[0].ownerDocument||this[0]).createDocumentFragment(),F=o.clean(J,(this[0].ownerDocument||this[0]),I),H=I.firstChild;if(H){for(var G=0,E=this.length;G<E;G++){L.call(K(this[G],H),this.length>1||G>0?I.cloneNode(true):I)}}if(F){o.each(F,z)}}return this;function K(N,O){return M&&o.nodeName(N,\"table\")&&o.nodeName(O,\"tr\")?(N.getElementsByTagName(\"tbody\")[0]||N.appendChild(N.ownerDocument.createElement(\"tbody\"))):N}}};o.fn.init.prototype=o.fn;function z(E,F){if(F.src){o.ajax({url:F.src,async:false,dataType:\"script\"})}else{o.globalEval(F.text||F.textContent||F.innerHTML||\"\")}if(F.parentNode){F.parentNode.removeChild(F)}}function e(){return +new Date}o.extend=o.fn.extend=function(){var J=arguments[0]||{},H=1,I=arguments.length,E=false,G;if(typeof J===\"boolean\"){E=J;J=arguments[1]||{};H=2}if(typeof J!==\"object\"&&!o.isFunction(J)){J={}}if(I==H){J=this;--H}for(;H<I;H++){if((G=arguments[H])!=null){for(var F in G){var K=J[F],L=G[F];if(J===L){continue}if(E&&L&&typeof L===\"object\"&&!L.nodeType){J[F]=o.extend(E,K||(L.length!=null?[]:{}),L)}else{if(L!==g){J[F]=L}}}}}return J};var b=/z-?index|font-?weight|opacity|zoom|line-?height/i,q=document.defaultView||{},s=Object.prototype.toString;o.extend({noConflict:function(E){l.$=p;if(E){l.jQuery=y}return o},isFunction:function(E){return s.call(E)===\"[object Function]\"},isArray:function(E){return s.call(E)===\"[object Array]\"},isXMLDoc:function(E){return E.nodeType===9&&E.documentElement.nodeName!==\"HTML\"||!!E.ownerDocument&&o.isXMLDoc(E.ownerDocument)},globalEval:function(G){if(G&&/\\S/.test(G)){var F=document.getElementsByTagName(\"head\")[0]||document.documentElement,E=document.createElement(\"script\");E.type=\"text/javascript\";if(o.support.scriptEval){E.appendChild(document.createTextNode(G))}else{E.text=G}F.insertBefore(E,F.firstChild);F.removeChild(E)}},nodeName:function(F,E){return F.nodeName&&F.nodeName.toUpperCase()==E.toUpperCase()},each:function(G,K,F){var E,H=0,I=G.length;if(F){if(I===g){for(E in G){if(K.apply(G[E],F)===false){break}}}else{for(;H<I;){if(K.apply(G[H++],F)===false){break}}}}else{if(I===g){for(E in G){if(K.call(G[E],E,G[E])===false){break}}}else{for(var J=G[0];H<I&&K.call(J,H,J)!==false;J=G[++H]){}}}return G},prop:function(H,I,G,F,E){if(o.isFunction(I)){I=I.call(H,F)}return typeof I===\"number\"&&G==\"curCSS\"&&!b.test(E)?I+\"px\":I},className:{add:function(E,F){o.each((F||\"\").split(/\\s+/),function(G,H){if(E.nodeType==1&&!o.className.has(E.className,H)){E.className+=(E.className?\" \":\"\")+H}})},remove:function(E,F){if(E.nodeType==1){E.className=F!==g?o.grep(E.className.split(/\\s+/),function(G){return !o.className.has(F,G)}).join(\" \"):\"\"}},has:function(F,E){return F&&o.inArray(E,(F.className||F).toString().split(/\\s+/))>-1}},swap:function(H,G,I){var E={};for(var F in G){E[F]=H.style[F];H.style[F]=G[F]}I.call(H);for(var F in G){H.style[F]=E[F]}},css:function(H,F,J,E){if(F==\"width\"||F==\"height\"){var L,G={position:\"absolute\",visibility:\"hidden\",display:\"block\"},K=F==\"width\"?[\"Left\",\"Right\"]:[\"Top\",\"Bottom\"];function I(){L=F==\"width\"?H.offsetWidth:H.offsetHeight;if(E===\"border\"){return}o.each(K,function(){if(!E){L-=parseFloat(o.curCSS(H,\"padding\"+this,true))||0}if(E===\"margin\"){L+=parseFloat(o.curCSS(H,\"margin\"+this,true))||0}else{L-=parseFloat(o.curCSS(H,\"border\"+this+\"Width\",true))||0}})}if(H.offsetWidth!==0){I()}else{o.swap(H,G,I)}return Math.max(0,Math.round(L))}return o.curCSS(H,F,J)},curCSS:function(I,F,G){var L,E=I.style;if(F==\"opacity\"&&!o.support.opacity){L=o.attr(E,\"opacity\");return L==\"\"?\"1\":L}if(F.match(/float/i)){F=w}if(!G&&E&&E[F]){L=E[F]}else{if(q.getComputedStyle){if(F.match(/float/i)){F=\"float\"}F=F.replace(/([A-Z])/g,\"-$1\").toLowerCase();var M=q.getComputedStyle(I,null);if(M){L=M.getPropertyValue(F)}if(F==\"opacity\"&&L==\"\"){L=\"1\"}}else{if(I.currentStyle){var J=F.replace(/\\-(\\w)/g,function(N,O){return O.toUpperCase()});L=I.currentStyle[F]||I.currentStyle[J];if(!/^\\d+(px)?$/i.test(L)&&/^\\d/.test(L)){var H=E.left,K=I.runtimeStyle.left;I.runtimeStyle.left=I.currentStyle.left;E.left=L||0;L=E.pixelLeft+\"px\";E.left=H;I.runtimeStyle.left=K}}}}return L},clean:function(F,K,I){K=K||document;if(typeof K.createElement===\"undefined\"){K=K.ownerDocument||K[0]&&K[0].ownerDocument||document}if(!I&&F.length===1&&typeof F[0]===\"string\"){var H=/^<(\\w+)\\s*\\/?>$/.exec(F[0]);if(H){return[K.createElement(H[1])]}}var G=[],E=[],L=K.createElement(\"div\");o.each(F,function(P,S){if(typeof S===\"number\"){S+=\"\"}if(!S){return}if(typeof S===\"string\"){S=S.replace(/(<(\\w+)[^>]*?)\\/>/g,function(U,V,T){return T.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i)?U:V+\"></\"+T+\">\"});var O=S.replace(/^\\s+/,\"\").substring(0,10).toLowerCase();var Q=!O.indexOf(\"<opt\")&&[1,\"<select multiple='multiple'>\",\"</select>\"]||!O.indexOf(\"<leg\")&&[1,\"<fieldset>\",\"</fieldset>\"]||O.match(/^<(thead|tbody|tfoot|colg|cap)/)&&[1,\"<table>\",\"</table>\"]||!O.indexOf(\"<tr\")&&[2,\"<table><tbody>\",\"</tbody></table>\"]||(!O.indexOf(\"<td\")||!O.indexOf(\"<th\"))&&[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"]||!O.indexOf(\"<col\")&&[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"]||!o.support.htmlSerialize&&[1,\"div<div>\",\"</div>\"]||[0,\"\",\"\"];L.innerHTML=Q[1]+S+Q[2];while(Q[0]--){L=L.lastChild}if(!o.support.tbody){var R=/<tbody/i.test(S),N=!O.indexOf(\"<table\")&&!R?L.firstChild&&L.firstChild.childNodes:Q[1]==\"<table>\"&&!R?L.childNodes:[];for(var M=N.length-1;M>=0;--M){if(o.nodeName(N[M],\"tbody\")&&!N[M].childNodes.length){N[M].parentNode.removeChild(N[M])}}}if(!o.support.leadingWhitespace&&/^\\s/.test(S)){L.insertBefore(K.createTextNode(S.match(/^\\s*/)[0]),L.firstChild)}S=o.makeArray(L.childNodes)}if(S.nodeType){G.push(S)}else{G=o.merge(G,S)}});if(I){for(var J=0;G[J];J++){if(o.nodeName(G[J],\"script\")&&(!G[J].type||G[J].type.toLowerCase()===\"text/javascript\")){E.push(G[J].parentNode?G[J].parentNode.removeChild(G[J]):G[J])}else{if(G[J].nodeType===1){G.splice.apply(G,[J+1,0].concat(o.makeArray(G[J].getElementsByTagName(\"script\"))))}I.appendChild(G[J])}}return E}return G},attr:function(J,G,K){if(!J||J.nodeType==3||J.nodeType==8){return g}var H=!o.isXMLDoc(J),L=K!==g;G=H&&o.props[G]||G;if(J.tagName){var F=/href|src|style/.test(G);if(G==\"selected\"&&J.parentNode){J.parentNode.selectedIndex}if(G in J&&H&&!F){if(L){if(G==\"type\"&&o.nodeName(J,\"input\")&&J.parentNode){throw\"type property can't be changed\"}J[G]=K}if(o.nodeName(J,\"form\")&&J.getAttributeNode(G)){return J.getAttributeNode(G).nodeValue}if(G==\"tabIndex\"){var I=J.getAttributeNode(\"tabIndex\");return I&&I.specified?I.value:J.nodeName.match(/(button|input|object|select|textarea)/i)?0:J.nodeName.match(/^(a|area)$/i)&&J.href?0:g}return J[G]}if(!o.support.style&&H&&G==\"style\"){return o.attr(J.style,\"cssText\",K)}if(L){J.setAttribute(G,\"\"+K)}var E=!o.support.hrefNormalized&&H&&F?J.getAttribute(G,2):J.getAttribute(G);return E===null?g:E}if(!o.support.opacity&&G==\"opacity\"){if(L){J.zoom=1;J.filter=(J.filter||\"\").replace(/alpha\\([^)]*\\)/,\"\")+(parseInt(K)+\"\"==\"NaN\"?\"\":\"alpha(opacity=\"+K*100+\")\")}return J.filter&&J.filter.indexOf(\"opacity=\")>=0?(parseFloat(J.filter.match(/opacity=([^)]*)/)[1])/100)+\"\":\"\"}G=G.replace(/-([a-z])/ig,function(M,N){return N.toUpperCase()});if(L){J[G]=K}return J[G]},trim:function(E){return(E||\"\").replace(/^\\s+|\\s+$/g,\"\")},makeArray:function(G){var E=[];if(G!=null){var F=G.length;if(F==null||typeof G===\"string\"||o.isFunction(G)||G.setInterval){E[0]=G}else{while(F){E[--F]=G[F]}}}return E},inArray:function(G,H){for(var E=0,F=H.length;E<F;E++){if(H[E]===G){return E}}return -1},merge:function(H,E){var F=0,G,I=H.length;if(!o.support.getAll){while((G=E[F++])!=null){if(G.nodeType!=8){H[I++]=G}}}else{while((G=E[F++])!=null){H[I++]=G}}return H},unique:function(K){var F=[],E={};try{for(var G=0,H=K.length;G<H;G++){var J=o.data(K[G]);if(!E[J]){E[J]=true;F.push(K[G])}}}catch(I){F=K}return F},grep:function(F,J,E){var G=[];for(var H=0,I=F.length;H<I;H++){if(!E!=!J(F[H],H)){G.push(F[H])}}return G},map:function(E,J){var F=[];for(var G=0,H=E.length;G<H;G++){var I=J(E[G],G);if(I!=null){F[F.length]=I}}return F.concat.apply([],F)}});var C=navigator.userAgent.toLowerCase();o.browser={version:(C.match(/.+(?:rv|it|ra|ie)[\\/: ]([\\d.]+)/)||[0,\"0\"])[1],safari:/webkit/.test(C),opera:/opera/.test(C),msie:/msie/.test(C)&&!/opera/.test(C),mozilla:/mozilla/.test(C)&&!/(compatible|webkit)/.test(C)};o.each({parent:function(E){return E.parentNode},parents:function(E){return o.dir(E,\"parentNode\")},next:function(E){return o.nth(E,2,\"nextSibling\")},prev:function(E){return o.nth(E,2,\"previousSibling\")},nextAll:function(E){return o.dir(E,\"nextSibling\")},prevAll:function(E){return o.dir(E,\"previousSibling\")},siblings:function(E){return o.sibling(E.parentNode.firstChild,E)},children:function(E){return o.sibling(E.firstChild)},contents:function(E){return o.nodeName(E,\"iframe\")?E.contentDocument||E.contentWindow.document:o.makeArray(E.childNodes)}},function(E,F){o.fn[E]=function(G){var H=o.map(this,F);if(G&&typeof G==\"string\"){H=o.multiFilter(G,H)}return this.pushStack(o.unique(H),E,G)}});o.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(E,F){o.fn[E]=function(G){var J=[],L=o(G);for(var K=0,H=L.length;K<H;K++){var I=(K>0?this.clone(true):this).get();o.fn[F].apply(o(L[K]),I);J=J.concat(I)}return this.pushStack(J,E,G)}});o.each({removeAttr:function(E){o.attr(this,E,\"\");if(this.nodeType==1){this.removeAttribute(E)}},addClass:function(E){o.className.add(this,E)},removeClass:function(E){o.className.remove(this,E)},toggleClass:function(F,E){if(typeof E!==\"boolean\"){E=!o.className.has(this,F)}o.className[E?\"add\":\"remove\"](this,F)},remove:function(E){if(!E||o.filter(E,[this]).length){o(\"*\",this).add([this]).each(function(){o.event.remove(this);o.removeData(this)});if(this.parentNode){this.parentNode.removeChild(this)}}},empty:function(){o(this).children().remove();while(this.firstChild){this.removeChild(this.firstChild)}}},function(E,F){o.fn[E]=function(){return this.each(F,arguments)}});function j(E,F){return E[0]&&parseInt(o.curCSS(E[0],F,true),10)||0}var h=\"jQuery\"+e(),v=0,A={};o.extend({cache:{},data:function(F,E,G){F=F==l?A:F;var H=F[h];if(!H){H=F[h]=++v}if(E&&!o.cache[H]){o.cache[H]={}}if(G!==g){o.cache[H][E]=G}return E?o.cache[H][E]:H},removeData:function(F,E){F=F==l?A:F;var H=F[h];if(E){if(o.cache[H]){delete o.cache[H][E];E=\"\";for(E in o.cache[H]){break}if(!E){o.removeData(F)}}}else{try{delete F[h]}catch(G){if(F.removeAttribute){F.removeAttribute(h)}}delete o.cache[H]}},queue:function(F,E,H){if(F){E=(E||\"fx\")+\"queue\";var G=o.data(F,E);if(!G||o.isArray(H)){G=o.data(F,E,o.makeArray(H))}else{if(H){G.push(H)}}}return G},dequeue:function(H,G){var E=o.queue(H,G),F=E.shift();if(!G||G===\"fx\"){F=E[0]}if(F!==g){F.call(H)}}});o.fn.extend({data:function(E,G){var H=E.split(\".\");H[1]=H[1]?\".\"+H[1]:\"\";if(G===g){var F=this.triggerHandler(\"getData\"+H[1]+\"!\",[H[0]]);if(F===g&&this.length){F=o.data(this[0],E)}return F===g&&H[1]?this.data(H[0]):F}else{return this.trigger(\"setData\"+H[1]+\"!\",[H[0],G]).each(function(){o.data(this,E,G)})}},removeData:function(E){return this.each(function(){o.removeData(this,E)})},queue:function(E,F){if(typeof E!==\"string\"){F=E;E=\"fx\"}if(F===g){return o.queue(this[0],E)}return this.each(function(){var G=o.queue(this,E,F);if(E==\"fx\"&&G.length==1){G[0].call(this)}})},dequeue:function(E){return this.each(function(){o.dequeue(this,E)})}});\n/*\n * Sizzle CSS Selector Engine - v0.9.3\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){var R=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,L=0,H=Object.prototype.toString;var F=function(Y,U,ab,ac){ab=ab||[];U=U||document;if(U.nodeType!==1&&U.nodeType!==9){return[]}if(!Y||typeof Y!==\"string\"){return ab}var Z=[],W,af,ai,T,ad,V,X=true;R.lastIndex=0;while((W=R.exec(Y))!==null){Z.push(W[1]);if(W[2]){V=RegExp.rightContext;break}}if(Z.length>1&&M.exec(Y)){if(Z.length===2&&I.relative[Z[0]]){af=J(Z[0]+Z[1],U)}else{af=I.relative[Z[0]]?[U]:F(Z.shift(),U);while(Z.length){Y=Z.shift();if(I.relative[Y]){Y+=Z.shift()}af=J(Y,af)}}}else{var ae=ac?{expr:Z.pop(),set:E(ac)}:F.find(Z.pop(),Z.length===1&&U.parentNode?U.parentNode:U,Q(U));af=F.filter(ae.expr,ae.set);if(Z.length>0){ai=E(af)}else{X=false}while(Z.length){var ah=Z.pop(),ag=ah;if(!I.relative[ah]){ah=\"\"}else{ag=Z.pop()}if(ag==null){ag=U}I.relative[ah](ai,ag,Q(U))}}if(!ai){ai=af}if(!ai){throw\"Syntax error, unrecognized expression: \"+(ah||Y)}if(H.call(ai)===\"[object Array]\"){if(!X){ab.push.apply(ab,ai)}else{if(U.nodeType===1){for(var aa=0;ai[aa]!=null;aa++){if(ai[aa]&&(ai[aa]===true||ai[aa].nodeType===1&&K(U,ai[aa]))){ab.push(af[aa])}}}else{for(var aa=0;ai[aa]!=null;aa++){if(ai[aa]&&ai[aa].nodeType===1){ab.push(af[aa])}}}}}else{E(ai,ab)}if(V){F(V,U,ab,ac);if(G){hasDuplicate=false;ab.sort(G);if(hasDuplicate){for(var aa=1;aa<ab.length;aa++){if(ab[aa]===ab[aa-1]){ab.splice(aa--,1)}}}}}return ab};F.matches=function(T,U){return F(T,null,null,U)};F.find=function(aa,T,ab){var Z,X;if(!aa){return[]}for(var W=0,V=I.order.length;W<V;W++){var Y=I.order[W],X;if((X=I.match[Y].exec(aa))){var U=RegExp.leftContext;if(U.substr(U.length-1)!==\"\\\\\"){X[1]=(X[1]||\"\").replace(/\\\\/g,\"\");Z=I.find[Y](X,T,ab);if(Z!=null){aa=aa.replace(I.match[Y],\"\");break}}}}if(!Z){Z=T.getElementsByTagName(\"*\")}return{set:Z,expr:aa}};F.filter=function(ad,ac,ag,W){var V=ad,ai=[],aa=ac,Y,T,Z=ac&&ac[0]&&Q(ac[0]);while(ad&&ac.length){for(var ab in I.filter){if((Y=I.match[ab].exec(ad))!=null){var U=I.filter[ab],ah,af;T=false;if(aa==ai){ai=[]}if(I.preFilter[ab]){Y=I.preFilter[ab](Y,aa,ag,ai,W,Z);if(!Y){T=ah=true}else{if(Y===true){continue}}}if(Y){for(var X=0;(af=aa[X])!=null;X++){if(af){ah=U(af,Y,X,aa);var ae=W^!!ah;if(ag&&ah!=null){if(ae){T=true}else{aa[X]=false}}else{if(ae){ai.push(af);T=true}}}}}if(ah!==g){if(!ag){aa=ai}ad=ad.replace(I.match[ab],\"\");if(!T){return[]}break}}}if(ad==V){if(T==null){throw\"Syntax error, unrecognized expression: \"+ad}else{break}}V=ad}return aa};var I=F.selectors={order:[\"ID\",\"NAME\",\"TAG\"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,NAME:/\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/},attrMap:{\"class\":\"className\",\"for\":\"htmlFor\"},attrHandle:{href:function(T){return T.getAttribute(\"href\")}},relative:{\"+\":function(aa,T,Z){var X=typeof T===\"string\",ab=X&&!/\\W/.test(T),Y=X&&!ab;if(ab&&!Z){T=T.toUpperCase()}for(var W=0,V=aa.length,U;W<V;W++){if((U=aa[W])){while((U=U.previousSibling)&&U.nodeType!==1){}aa[W]=Y||U&&U.nodeName===T?U||false:U===T}}if(Y){F.filter(T,aa,true)}},\">\":function(Z,U,aa){var X=typeof U===\"string\";if(X&&!/\\W/.test(U)){U=aa?U:U.toUpperCase();for(var V=0,T=Z.length;V<T;V++){var Y=Z[V];if(Y){var W=Y.parentNode;Z[V]=W.nodeName===U?W:false}}}else{for(var V=0,T=Z.length;V<T;V++){var Y=Z[V];if(Y){Z[V]=X?Y.parentNode:Y.parentNode===U}}if(X){F.filter(U,Z,true)}}},\"\":function(W,U,Y){var V=L++,T=S;if(!U.match(/\\W/)){var X=U=Y?U:U.toUpperCase();T=P}T(\"parentNode\",U,V,W,X,Y)},\"~\":function(W,U,Y){var V=L++,T=S;if(typeof U===\"string\"&&!U.match(/\\W/)){var X=U=Y?U:U.toUpperCase();T=P}T(\"previousSibling\",U,V,W,X,Y)}},find:{ID:function(U,V,W){if(typeof V.getElementById!==\"undefined\"&&!W){var T=V.getElementById(U[1]);return T?[T]:[]}},NAME:function(V,Y,Z){if(typeof Y.getElementsByName!==\"undefined\"){var U=[],X=Y.getElementsByName(V[1]);for(var W=0,T=X.length;W<T;W++){if(X[W].getAttribute(\"name\")===V[1]){U.push(X[W])}}return U.length===0?null:U}},TAG:function(T,U){return U.getElementsByTagName(T[1])}},preFilter:{CLASS:function(W,U,V,T,Z,aa){W=\" \"+W[1].replace(/\\\\/g,\"\")+\" \";if(aa){return W}for(var X=0,Y;(Y=U[X])!=null;X++){if(Y){if(Z^(Y.className&&(\" \"+Y.className+\" \").indexOf(W)>=0)){if(!V){T.push(Y)}}else{if(V){U[X]=false}}}}return false},ID:function(T){return T[1].replace(/\\\\/g,\"\")},TAG:function(U,T){for(var V=0;T[V]===false;V++){}return T[V]&&Q(T[V])?U[1]:U[1].toUpperCase()},CHILD:function(T){if(T[1]==\"nth\"){var U=/(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(T[2]==\"even\"&&\"2n\"||T[2]==\"odd\"&&\"2n+1\"||!/\\D/.test(T[2])&&\"0n+\"+T[2]||T[2]);T[2]=(U[1]+(U[2]||1))-0;T[3]=U[3]-0}T[0]=L++;return T},ATTR:function(X,U,V,T,Y,Z){var W=X[1].replace(/\\\\/g,\"\");if(!Z&&I.attrMap[W]){X[1]=I.attrMap[W]}if(X[2]===\"~=\"){X[4]=\" \"+X[4]+\" \"}return X},PSEUDO:function(X,U,V,T,Y){if(X[1]===\"not\"){if(X[3].match(R).length>1||/^\\w/.test(X[3])){X[3]=F(X[3],null,null,U)}else{var W=F.filter(X[3],U,V,true^Y);if(!V){T.push.apply(T,W)}return false}}else{if(I.match.POS.test(X[0])||I.match.CHILD.test(X[0])){return true}}return X},POS:function(T){T.unshift(true);return T}},filters:{enabled:function(T){return T.disabled===false&&T.type!==\"hidden\"},disabled:function(T){return T.disabled===true},checked:function(T){return T.checked===true},selected:function(T){T.parentNode.selectedIndex;return T.selected===true},parent:function(T){return !!T.firstChild},empty:function(T){return !T.firstChild},has:function(V,U,T){return !!F(T[3],V).length},header:function(T){return/h\\d/i.test(T.nodeName)},text:function(T){return\"text\"===T.type},radio:function(T){return\"radio\"===T.type},checkbox:function(T){return\"checkbox\"===T.type},file:function(T){return\"file\"===T.type},password:function(T){return\"password\"===T.type},submit:function(T){return\"submit\"===T.type},image:function(T){return\"image\"===T.type},reset:function(T){return\"reset\"===T.type},button:function(T){return\"button\"===T.type||T.nodeName.toUpperCase()===\"BUTTON\"},input:function(T){return/input|select|textarea|button/i.test(T.nodeName)}},setFilters:{first:function(U,T){return T===0},last:function(V,U,T,W){return U===W.length-1},even:function(U,T){return T%2===0},odd:function(U,T){return T%2===1},lt:function(V,U,T){return U<T[3]-0},gt:function(V,U,T){return U>T[3]-0},nth:function(V,U,T){return T[3]-0==U},eq:function(V,U,T){return T[3]-0==U}},filter:{PSEUDO:function(Z,V,W,aa){var U=V[1],X=I.filters[U];if(X){return X(Z,W,V,aa)}else{if(U===\"contains\"){return(Z.textContent||Z.innerText||\"\").indexOf(V[3])>=0}else{if(U===\"not\"){var Y=V[3];for(var W=0,T=Y.length;W<T;W++){if(Y[W]===Z){return false}}return true}}}},CHILD:function(T,W){var Z=W[1],U=T;switch(Z){case\"only\":case\"first\":while(U=U.previousSibling){if(U.nodeType===1){return false}}if(Z==\"first\"){return true}U=T;case\"last\":while(U=U.nextSibling){if(U.nodeType===1){return false}}return true;case\"nth\":var V=W[2],ac=W[3];if(V==1&&ac==0){return true}var Y=W[0],ab=T.parentNode;if(ab&&(ab.sizcache!==Y||!T.nodeIndex)){var X=0;for(U=ab.firstChild;U;U=U.nextSibling){if(U.nodeType===1){U.nodeIndex=++X}}ab.sizcache=Y}var aa=T.nodeIndex-ac;if(V==0){return aa==0}else{return(aa%V==0&&aa/V>=0)}}},ID:function(U,T){return U.nodeType===1&&U.getAttribute(\"id\")===T},TAG:function(U,T){return(T===\"*\"&&U.nodeType===1)||U.nodeName===T},CLASS:function(U,T){return(\" \"+(U.className||U.getAttribute(\"class\"))+\" \").indexOf(T)>-1},ATTR:function(Y,W){var V=W[1],T=I.attrHandle[V]?I.attrHandle[V](Y):Y[V]!=null?Y[V]:Y.getAttribute(V),Z=T+\"\",X=W[2],U=W[4];return T==null?X===\"!=\":X===\"=\"?Z===U:X===\"*=\"?Z.indexOf(U)>=0:X===\"~=\"?(\" \"+Z+\" \").indexOf(U)>=0:!U?Z&&T!==false:X===\"!=\"?Z!=U:X===\"^=\"?Z.indexOf(U)===0:X===\"$=\"?Z.substr(Z.length-U.length)===U:X===\"|=\"?Z===U||Z.substr(0,U.length+1)===U+\"-\":false},POS:function(X,U,V,Y){var T=U[2],W=I.setFilters[T];if(W){return W(X,V,U,Y)}}}};var M=I.match.POS;for(var O in I.match){I.match[O]=RegExp(I.match[O].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source)}var E=function(U,T){U=Array.prototype.slice.call(U);if(T){T.push.apply(T,U);return T}return U};try{Array.prototype.slice.call(document.documentElement.childNodes)}catch(N){E=function(X,W){var U=W||[];if(H.call(X)===\"[object Array]\"){Array.prototype.push.apply(U,X)}else{if(typeof X.length===\"number\"){for(var V=0,T=X.length;V<T;V++){U.push(X[V])}}else{for(var V=0;X[V];V++){U.push(X[V])}}}return U}}var G;if(document.documentElement.compareDocumentPosition){G=function(U,T){var V=U.compareDocumentPosition(T)&4?-1:U===T?0:1;if(V===0){hasDuplicate=true}return V}}else{if(\"sourceIndex\" in document.documentElement){G=function(U,T){var V=U.sourceIndex-T.sourceIndex;if(V===0){hasDuplicate=true}return V}}else{if(document.createRange){G=function(W,U){var V=W.ownerDocument.createRange(),T=U.ownerDocument.createRange();V.selectNode(W);V.collapse(true);T.selectNode(U);T.collapse(true);var X=V.compareBoundaryPoints(Range.START_TO_END,T);if(X===0){hasDuplicate=true}return X}}}}(function(){var U=document.createElement(\"form\"),V=\"script\"+(new Date).getTime();U.innerHTML=\"<input name='\"+V+\"'/>\";var T=document.documentElement;T.insertBefore(U,T.firstChild);if(!!document.getElementById(V)){I.find.ID=function(X,Y,Z){if(typeof Y.getElementById!==\"undefined\"&&!Z){var W=Y.getElementById(X[1]);return W?W.id===X[1]||typeof W.getAttributeNode!==\"undefined\"&&W.getAttributeNode(\"id\").nodeValue===X[1]?[W]:g:[]}};I.filter.ID=function(Y,W){var X=typeof Y.getAttributeNode!==\"undefined\"&&Y.getAttributeNode(\"id\");return Y.nodeType===1&&X&&X.nodeValue===W}}T.removeChild(U)})();(function(){var T=document.createElement(\"div\");T.appendChild(document.createComment(\"\"));if(T.getElementsByTagName(\"*\").length>0){I.find.TAG=function(U,Y){var X=Y.getElementsByTagName(U[1]);if(U[1]===\"*\"){var W=[];for(var V=0;X[V];V++){if(X[V].nodeType===1){W.push(X[V])}}X=W}return X}}T.innerHTML=\"<a href='#'></a>\";if(T.firstChild&&typeof T.firstChild.getAttribute!==\"undefined\"&&T.firstChild.getAttribute(\"href\")!==\"#\"){I.attrHandle.href=function(U){return U.getAttribute(\"href\",2)}}})();if(document.querySelectorAll){(function(){var T=F,U=document.createElement(\"div\");U.innerHTML=\"<p class='TEST'></p>\";if(U.querySelectorAll&&U.querySelectorAll(\".TEST\").length===0){return}F=function(Y,X,V,W){X=X||document;if(!W&&X.nodeType===9&&!Q(X)){try{return E(X.querySelectorAll(Y),V)}catch(Z){}}return T(Y,X,V,W)};F.find=T.find;F.filter=T.filter;F.selectors=T.selectors;F.matches=T.matches})()}if(document.getElementsByClassName&&document.documentElement.getElementsByClassName){(function(){var T=document.createElement(\"div\");T.innerHTML=\"<div class='test e'></div><div class='test'></div>\";if(T.getElementsByClassName(\"e\").length===0){return}T.lastChild.className=\"e\";if(T.getElementsByClassName(\"e\").length===1){return}I.order.splice(1,0,\"CLASS\");I.find.CLASS=function(U,V,W){if(typeof V.getElementsByClassName!==\"undefined\"&&!W){return V.getElementsByClassName(U[1])}}})()}function P(U,Z,Y,ad,aa,ac){var ab=U==\"previousSibling\"&&!ac;for(var W=0,V=ad.length;W<V;W++){var T=ad[W];if(T){if(ab&&T.nodeType===1){T.sizcache=Y;T.sizset=W}T=T[U];var X=false;while(T){if(T.sizcache===Y){X=ad[T.sizset];break}if(T.nodeType===1&&!ac){T.sizcache=Y;T.sizset=W}if(T.nodeName===Z){X=T;break}T=T[U]}ad[W]=X}}}function S(U,Z,Y,ad,aa,ac){var ab=U==\"previousSibling\"&&!ac;for(var W=0,V=ad.length;W<V;W++){var T=ad[W];if(T){if(ab&&T.nodeType===1){T.sizcache=Y;T.sizset=W}T=T[U];var X=false;while(T){if(T.sizcache===Y){X=ad[T.sizset];break}if(T.nodeType===1){if(!ac){T.sizcache=Y;T.sizset=W}if(typeof Z!==\"string\"){if(T===Z){X=true;break}}else{if(F.filter(Z,[T]).length>0){X=T;break}}}T=T[U]}ad[W]=X}}}var K=document.compareDocumentPosition?function(U,T){return U.compareDocumentPosition(T)&16}:function(U,T){return U!==T&&(U.contains?U.contains(T):true)};var Q=function(T){return T.nodeType===9&&T.documentElement.nodeName!==\"HTML\"||!!T.ownerDocument&&Q(T.ownerDocument)};var J=function(T,aa){var W=[],X=\"\",Y,V=aa.nodeType?[aa]:aa;while((Y=I.match.PSEUDO.exec(T))){X+=Y[0];T=T.replace(I.match.PSEUDO,\"\")}T=I.relative[T]?T+\"*\":T;for(var Z=0,U=V.length;Z<U;Z++){F(T,V[Z],W)}return F.filter(X,W)};o.find=F;o.filter=F.filter;o.expr=F.selectors;o.expr[\":\"]=o.expr.filters;F.selectors.filters.hidden=function(T){return T.offsetWidth===0||T.offsetHeight===0};F.selectors.filters.visible=function(T){return T.offsetWidth>0||T.offsetHeight>0};F.selectors.filters.animated=function(T){return o.grep(o.timers,function(U){return T===U.elem}).length};o.multiFilter=function(V,T,U){if(U){V=\":not(\"+V+\")\"}return F.matches(V,T)};o.dir=function(V,U){var T=[],W=V[U];while(W&&W!=document){if(W.nodeType==1){T.push(W)}W=W[U]}return T};o.nth=function(X,T,V,W){T=T||1;var U=0;for(;X;X=X[V]){if(X.nodeType==1&&++U==T){break}}return X};o.sibling=function(V,U){var T=[];for(;V;V=V.nextSibling){if(V.nodeType==1&&V!=U){T.push(V)}}return T};return;l.Sizzle=F})();o.event={add:function(I,F,H,K){if(I.nodeType==3||I.nodeType==8){return}if(I.setInterval&&I!=l){I=l}if(!H.guid){H.guid=this.guid++}if(K!==g){var G=H;H=this.proxy(G);H.data=K}var E=o.data(I,\"events\")||o.data(I,\"events\",{}),J=o.data(I,\"handle\")||o.data(I,\"handle\",function(){return typeof o!==\"undefined\"&&!o.event.triggered?o.event.handle.apply(arguments.callee.elem,arguments):g});J.elem=I;o.each(F.split(/\\s+/),function(M,N){var O=N.split(\".\");N=O.shift();H.type=O.slice().sort().join(\".\");var L=E[N];if(o.event.specialAll[N]){o.event.specialAll[N].setup.call(I,K,O)}if(!L){L=E[N]={};if(!o.event.special[N]||o.event.special[N].setup.call(I,K,O)===false){if(I.addEventListener){I.addEventListener(N,J,false)}else{if(I.attachEvent){I.attachEvent(\"on\"+N,J)}}}}L[H.guid]=H;o.event.global[N]=true});I=null},guid:1,global:{},remove:function(K,H,J){if(K.nodeType==3||K.nodeType==8){return}var G=o.data(K,\"events\"),F,E;if(G){if(H===g||(typeof H===\"string\"&&H.charAt(0)==\".\")){for(var I in G){this.remove(K,I+(H||\"\"))}}else{if(H.type){J=H.handler;H=H.type}o.each(H.split(/\\s+/),function(M,O){var Q=O.split(\".\");O=Q.shift();var N=RegExp(\"(^|\\\\.)\"+Q.slice().sort().join(\".*\\\\.\")+\"(\\\\.|$)\");if(G[O]){if(J){delete G[O][J.guid]}else{for(var P in G[O]){if(N.test(G[O][P].type)){delete G[O][P]}}}if(o.event.specialAll[O]){o.event.specialAll[O].teardown.call(K,Q)}for(F in G[O]){break}if(!F){if(!o.event.special[O]||o.event.special[O].teardown.call(K,Q)===false){if(K.removeEventListener){K.removeEventListener(O,o.data(K,\"handle\"),false)}else{if(K.detachEvent){K.detachEvent(\"on\"+O,o.data(K,\"handle\"))}}}F=null;delete G[O]}}})}for(F in G){break}if(!F){var L=o.data(K,\"handle\");if(L){L.elem=null}o.removeData(K,\"events\");o.removeData(K,\"handle\")}}},trigger:function(I,K,H,E){var G=I.type||I;if(!E){I=typeof I===\"object\"?I[h]?I:o.extend(o.Event(G),I):o.Event(G);if(G.indexOf(\"!\")>=0){I.type=G=G.slice(0,-1);I.exclusive=true}if(!H){I.stopPropagation();if(this.global[G]){o.each(o.cache,function(){if(this.events&&this.events[G]){o.event.trigger(I,K,this.handle.elem)}})}}if(!H||H.nodeType==3||H.nodeType==8){return g}I.result=g;I.target=H;K=o.makeArray(K);K.unshift(I)}I.currentTarget=H;var J=o.data(H,\"handle\");if(J){J.apply(H,K)}if((!H[G]||(o.nodeName(H,\"a\")&&G==\"click\"))&&H[\"on\"+G]&&H[\"on\"+G].apply(H,K)===false){I.result=false}if(!E&&H[G]&&!I.isDefaultPrevented()&&!(o.nodeName(H,\"a\")&&G==\"click\")){this.triggered=true;try{H[G]()}catch(L){}}this.triggered=false;if(!I.isPropagationStopped()){var F=H.parentNode||H.ownerDocument;if(F){o.event.trigger(I,K,F,true)}}},handle:function(K){var J,E;K=arguments[0]=o.event.fix(K||l.event);K.currentTarget=this;var L=K.type.split(\".\");K.type=L.shift();J=!L.length&&!K.exclusive;var I=RegExp(\"(^|\\\\.)\"+L.slice().sort().join(\".*\\\\.\")+\"(\\\\.|$)\");E=(o.data(this,\"events\")||{})[K.type];for(var G in E){var H=E[G];if(J||I.test(H.type)){K.handler=H;K.data=H.data;var F=H.apply(this,arguments);if(F!==g){K.result=F;if(F===false){K.preventDefault();K.stopPropagation()}}if(K.isImmediatePropagationStopped()){break}}}},props:\"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode metaKey newValue originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"),fix:function(H){if(H[h]){return H}var F=H;H=o.Event(F);for(var G=this.props.length,J;G;){J=this.props[--G];H[J]=F[J]}if(!H.target){H.target=H.srcElement||document}if(H.target.nodeType==3){H.target=H.target.parentNode}if(!H.relatedTarget&&H.fromElement){H.relatedTarget=H.fromElement==H.target?H.toElement:H.fromElement}if(H.pageX==null&&H.clientX!=null){var I=document.documentElement,E=document.body;H.pageX=H.clientX+(I&&I.scrollLeft||E&&E.scrollLeft||0)-(I.clientLeft||0);H.pageY=H.clientY+(I&&I.scrollTop||E&&E.scrollTop||0)-(I.clientTop||0)}if(!H.which&&((H.charCode||H.charCode===0)?H.charCode:H.keyCode)){H.which=H.charCode||H.keyCode}if(!H.metaKey&&H.ctrlKey){H.metaKey=H.ctrlKey}if(!H.which&&H.button){H.which=(H.button&1?1:(H.button&2?3:(H.button&4?2:0)))}return H},proxy:function(F,E){E=E||function(){return F.apply(this,arguments)};E.guid=F.guid=F.guid||E.guid||this.guid++;return E},special:{ready:{setup:B,teardown:function(){}}},specialAll:{live:{setup:function(E,F){o.event.add(this,F[0],c)},teardown:function(G){if(G.length){var E=0,F=RegExp(\"(^|\\\\.)\"+G[0]+\"(\\\\.|$)\");o.each((o.data(this,\"events\").live||{}),function(){if(F.test(this.type)){E++}});if(E<1){o.event.remove(this,G[0],c)}}}}}};o.Event=function(E){if(!this.preventDefault){return new o.Event(E)}if(E&&E.type){this.originalEvent=E;this.type=E.type}else{this.type=E}this.timeStamp=e();this[h]=true};function k(){return false}function u(){return true}o.Event.prototype={preventDefault:function(){this.isDefaultPrevented=u;var E=this.originalEvent;if(!E){return}if(E.preventDefault){E.preventDefault()}E.returnValue=false},stopPropagation:function(){this.isPropagationStopped=u;var E=this.originalEvent;if(!E){return}if(E.stopPropagation){E.stopPropagation()}E.cancelBubble=true},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=u;this.stopPropagation()},isDefaultPrevented:k,isPropagationStopped:k,isImmediatePropagationStopped:k};var a=function(F){var E=F.relatedTarget;while(E&&E!=this){try{E=E.parentNode}catch(G){E=this}}if(E!=this){F.type=F.data;o.event.handle.apply(this,arguments)}};o.each({mouseover:\"mouseenter\",mouseout:\"mouseleave\"},function(F,E){o.event.special[E]={setup:function(){o.event.add(this,F,a,E)},teardown:function(){o.event.remove(this,F,a)}}});o.fn.extend({bind:function(F,G,E){return F==\"unload\"?this.one(F,G,E):this.each(function(){o.event.add(this,F,E||G,E&&G)})},one:function(G,H,F){var E=o.event.proxy(F||H,function(I){o(this).unbind(I,E);return(F||H).apply(this,arguments)});return this.each(function(){o.event.add(this,G,E,F&&H)})},unbind:function(F,E){return this.each(function(){o.event.remove(this,F,E)})},trigger:function(E,F){return this.each(function(){o.event.trigger(E,F,this)})},triggerHandler:function(E,G){if(this[0]){var F=o.Event(E);F.preventDefault();F.stopPropagation();o.event.trigger(F,G,this[0]);return F.result}},toggle:function(G){var E=arguments,F=1;while(F<E.length){o.event.proxy(G,E[F++])}return this.click(o.event.proxy(G,function(H){this.lastToggle=(this.lastToggle||0)%F;H.preventDefault();return E[this.lastToggle++].apply(this,arguments)||false}))},hover:function(E,F){return this.mouseenter(E).mouseleave(F)},ready:function(E){B();if(o.isReady){E.call(document,o)}else{o.readyList.push(E)}return this},live:function(G,F){var E=o.event.proxy(F);E.guid+=this.selector+G;o(document).bind(i(G,this.selector),this.selector,E);return this},die:function(F,E){o(document).unbind(i(F,this.selector),E?{guid:E.guid+this.selector+F}:null);return this}});function c(H){var E=RegExp(\"(^|\\\\.)\"+H.type+\"(\\\\.|$)\"),G=true,F=[];o.each(o.data(this,\"events\").live||[],function(I,J){if(E.test(J.type)){var K=o(H.target).closest(J.data)[0];if(K){F.push({elem:K,fn:J})}}});F.sort(function(J,I){return o.data(J.elem,\"closest\")-o.data(I.elem,\"closest\")});o.each(F,function(){if(this.fn.call(this.elem,H,this.fn.data)===false){return(G=false)}});return G}function i(F,E){return[\"live\",F,E.replace(/\\./g,\"`\").replace(/ /g,\"|\")].join(\".\")}o.extend({isReady:false,readyList:[],ready:function(){if(!o.isReady){o.isReady=true;if(o.readyList){o.each(o.readyList,function(){this.call(document,o)});o.readyList=null}o(document).triggerHandler(\"ready\")}}});var x=false;function B(){if(x){return}x=true;if(document.addEventListener){document.addEventListener(\"DOMContentLoaded\",function(){document.removeEventListener(\"DOMContentLoaded\",arguments.callee,false);o.ready()},false)}else{if(document.attachEvent){document.attachEvent(\"onreadystatechange\",function(){if(document.readyState===\"complete\"){document.detachEvent(\"onreadystatechange\",arguments.callee);o.ready()}});if(document.documentElement.doScroll&&l==l.top){(function(){if(o.isReady){return}try{document.documentElement.doScroll(\"left\")}catch(E){setTimeout(arguments.callee,0);return}o.ready()})()}}}o.event.add(l,\"load\",o.ready)}o.each((\"blur,focus,load,resize,scroll,unload,click,dblclick,mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,change,select,submit,keydown,keypress,keyup,error\").split(\",\"),function(F,E){o.fn[E]=function(G){return G?this.bind(E,G):this.trigger(E)}});o(l).bind(\"unload\",function(){for(var E in o.cache){if(E!=1&&o.cache[E].handle){o.event.remove(o.cache[E].handle.elem)}}});(function(){o.support={};var F=document.documentElement,G=document.createElement(\"script\"),K=document.createElement(\"div\"),J=\"script\"+(new Date).getTime();K.style.display=\"none\";K.innerHTML='   <link/><table></table><a href=\"/a\" style=\"color:red;float:left;opacity:.5;\">a</a><select><option>text</option></select><object><param/></object>';var H=K.getElementsByTagName(\"*\"),E=K.getElementsByTagName(\"a\")[0];if(!H||!H.length||!E){return}o.support={leadingWhitespace:K.firstChild.nodeType==3,tbody:!K.getElementsByTagName(\"tbody\").length,objectAll:!!K.getElementsByTagName(\"object\")[0].getElementsByTagName(\"*\").length,htmlSerialize:!!K.getElementsByTagName(\"link\").length,style:/red/.test(E.getAttribute(\"style\")),hrefNormalized:E.getAttribute(\"href\")===\"/a\",opacity:E.style.opacity===\"0.5\",cssFloat:!!E.style.cssFloat,scriptEval:false,noCloneEvent:true,boxModel:null};G.type=\"text/javascript\";try{G.appendChild(document.createTextNode(\"window.\"+J+\"=1;\"))}catch(I){}F.insertBefore(G,F.firstChild);if(l[J]){o.support.scriptEval=true;delete l[J]}F.removeChild(G);if(K.attachEvent&&K.fireEvent){K.attachEvent(\"onclick\",function(){o.support.noCloneEvent=false;K.detachEvent(\"onclick\",arguments.callee)});K.cloneNode(true).fireEvent(\"onclick\")}o(function(){var L=document.createElement(\"div\");L.style.width=L.style.paddingLeft=\"1px\";document.body.appendChild(L);o.boxModel=o.support.boxModel=L.offsetWidth===2;document.body.removeChild(L).style.display=\"none\"})})();var w=o.support.cssFloat?\"cssFloat\":\"styleFloat\";o.props={\"for\":\"htmlFor\",\"class\":\"className\",\"float\":w,cssFloat:w,styleFloat:w,readonly:\"readOnly\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",rowspan:\"rowSpan\",tabindex:\"tabIndex\"};o.fn.extend({_load:o.fn.load,load:function(G,J,K){if(typeof G!==\"string\"){return this._load(G)}var I=G.indexOf(\" \");if(I>=0){var E=G.slice(I,G.length);G=G.slice(0,I)}var H=\"GET\";if(J){if(o.isFunction(J)){K=J;J=null}else{if(typeof J===\"object\"){J=o.param(J);H=\"POST\"}}}var F=this;o.ajax({url:G,type:H,dataType:\"html\",data:J,complete:function(M,L){if(L==\"success\"||L==\"notmodified\"){F.html(E?o(\"<div/>\").append(M.responseText.replace(/<script(.|\\s)*?\\/script>/g,\"\")).find(E):M.responseText)}if(K){F.each(K,[M.responseText,L,M])}}});return this},serialize:function(){return o.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?o.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||/select|textarea/i.test(this.nodeName)||/text|hidden|password|search/i.test(this.type))}).map(function(E,F){var G=o(this).val();return G==null?null:o.isArray(G)?o.map(G,function(I,H){return{name:F.name,value:I}}):{name:F.name,value:G}}).get()}});o.each(\"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"),function(E,F){o.fn[F]=function(G){return this.bind(F,G)}});var r=e();o.extend({get:function(E,G,H,F){if(o.isFunction(G)){H=G;G=null}return o.ajax({type:\"GET\",url:E,data:G,success:H,dataType:F})},getScript:function(E,F){return o.get(E,null,F,\"script\")},getJSON:function(E,F,G){return o.get(E,F,G,\"json\")},post:function(E,G,H,F){if(o.isFunction(G)){H=G;G={}}return o.ajax({type:\"POST\",url:E,data:G,success:H,dataType:F})},ajaxSetup:function(E){o.extend(o.ajaxSettings,E)},ajaxSettings:{url:location.href,global:true,type:\"GET\",contentType:\"application/x-www-form-urlencoded\",processData:true,async:true,xhr:function(){return l.ActiveXObject?new ActiveXObject(\"Microsoft.XMLHTTP\"):new XMLHttpRequest()},accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",script:\"text/javascript, application/javascript\",json:\"application/json, text/javascript\",text:\"text/plain\",_default:\"*/*\"}},lastModified:{},ajax:function(M){M=o.extend(true,M,o.extend(true,{},o.ajaxSettings,M));var W,F=/=\\?(&|$)/g,R,V,G=M.type.toUpperCase();if(M.data&&M.processData&&typeof M.data!==\"string\"){M.data=o.param(M.data)}if(M.dataType==\"jsonp\"){if(G==\"GET\"){if(!M.url.match(F)){M.url+=(M.url.match(/\\?/)?\"&\":\"?\")+(M.jsonp||\"callback\")+\"=?\"}}else{if(!M.data||!M.data.match(F)){M.data=(M.data?M.data+\"&\":\"\")+(M.jsonp||\"callback\")+\"=?\"}}M.dataType=\"json\"}if(M.dataType==\"json\"&&(M.data&&M.data.match(F)||M.url.match(F))){W=\"jsonp\"+r++;if(M.data){M.data=(M.data+\"\").replace(F,\"=\"+W+\"$1\")}M.url=M.url.replace(F,\"=\"+W+\"$1\");M.dataType=\"script\";l[W]=function(X){V=X;I();L();l[W]=g;try{delete l[W]}catch(Y){}if(H){H.removeChild(T)}}}if(M.dataType==\"script\"&&M.cache==null){M.cache=false}if(M.cache===false&&G==\"GET\"){var E=e();var U=M.url.replace(/(\\?|&)_=.*?(&|$)/,\"$1_=\"+E+\"$2\");M.url=U+((U==M.url)?(M.url.match(/\\?/)?\"&\":\"?\")+\"_=\"+E:\"\")}if(M.data&&G==\"GET\"){M.url+=(M.url.match(/\\?/)?\"&\":\"?\")+M.data;M.data=null}if(M.global&&!o.active++){o.event.trigger(\"ajaxStart\")}var Q=/^(\\w+:)?\\/\\/([^\\/?#]+)/.exec(M.url);if(M.dataType==\"script\"&&G==\"GET\"&&Q&&(Q[1]&&Q[1]!=location.protocol||Q[2]!=location.host)){var H=document.getElementsByTagName(\"head\")[0];var T=document.createElement(\"script\");T.src=M.url;if(M.scriptCharset){T.charset=M.scriptCharset}if(!W){var O=false;T.onload=T.onreadystatechange=function(){if(!O&&(!this.readyState||this.readyState==\"loaded\"||this.readyState==\"complete\")){O=true;I();L();T.onload=T.onreadystatechange=null;H.removeChild(T)}}}H.appendChild(T);return g}var K=false;var J=M.xhr();if(M.username){J.open(G,M.url,M.async,M.username,M.password)}else{J.open(G,M.url,M.async)}try{if(M.data){J.setRequestHeader(\"Content-Type\",M.contentType)}if(M.ifModified){J.setRequestHeader(\"If-Modified-Since\",o.lastModified[M.url]||\"Thu, 01 Jan 1970 00:00:00 GMT\")}J.setRequestHeader(\"X-Requested-With\",\"XMLHttpRequest\");J.setRequestHeader(\"Accept\",M.dataType&&M.accepts[M.dataType]?M.accepts[M.dataType]+\", */*\":M.accepts._default)}catch(S){}if(M.beforeSend&&M.beforeSend(J,M)===false){if(M.global&&!--o.active){o.event.trigger(\"ajaxStop\")}J.abort();return false}if(M.global){o.event.trigger(\"ajaxSend\",[J,M])}var N=function(X){if(J.readyState==0){if(P){clearInterval(P);P=null;if(M.global&&!--o.active){o.event.trigger(\"ajaxStop\")}}}else{if(!K&&J&&(J.readyState==4||X==\"timeout\")){K=true;if(P){clearInterval(P);P=null}R=X==\"timeout\"?\"timeout\":!o.httpSuccess(J)?\"error\":M.ifModified&&o.httpNotModified(J,M.url)?\"notmodified\":\"success\";if(R==\"success\"){try{V=o.httpData(J,M.dataType,M)}catch(Z){R=\"parsererror\"}}if(R==\"success\"){var Y;try{Y=J.getResponseHeader(\"Last-Modified\")}catch(Z){}if(M.ifModified&&Y){o.lastModified[M.url]=Y}if(!W){I()}}else{o.handleError(M,J,R)}L();if(X){J.abort()}if(M.async){J=null}}}};if(M.async){var P=setInterval(N,13);if(M.timeout>0){setTimeout(function(){if(J&&!K){N(\"timeout\")}},M.timeout)}}try{J.send(M.data)}catch(S){o.handleError(M,J,null,S)}if(!M.async){N()}function I(){if(M.success){M.success(V,R)}if(M.global){o.event.trigger(\"ajaxSuccess\",[J,M])}}function L(){if(M.complete){M.complete(J,R)}if(M.global){o.event.trigger(\"ajaxComplete\",[J,M])}if(M.global&&!--o.active){o.event.trigger(\"ajaxStop\")}}return J},handleError:function(F,H,E,G){if(F.error){F.error(H,E,G)}if(F.global){o.event.trigger(\"ajaxError\",[H,F,G])}},active:0,httpSuccess:function(F){try{return !F.status&&location.protocol==\"file:\"||(F.status>=200&&F.status<300)||F.status==304||F.status==1223}catch(E){}return false},httpNotModified:function(G,E){try{var H=G.getResponseHeader(\"Last-Modified\");return G.status==304||H==o.lastModified[E]}catch(F){}return false},httpData:function(J,H,G){var F=J.getResponseHeader(\"content-type\"),E=H==\"xml\"||!H&&F&&F.indexOf(\"xml\")>=0,I=E?J.responseXML:J.responseText;if(E&&I.documentElement.tagName==\"parsererror\"){throw\"parsererror\"}if(G&&G.dataFilter){I=G.dataFilter(I,H)}if(typeof I===\"string\"){if(H==\"script\"){o.globalEval(I)}if(H==\"json\"){I=l[\"eval\"](\"(\"+I+\")\")}}return I},param:function(E){var G=[];function H(I,J){G[G.length]=encodeURIComponent(I)+\"=\"+encodeURIComponent(J)}if(o.isArray(E)||E.jquery){o.each(E,function(){H(this.name,this.value)})}else{for(var F in E){if(o.isArray(E[F])){o.each(E[F],function(){H(F,this)})}else{H(F,o.isFunction(E[F])?E[F]():E[F])}}}return G.join(\"&\").replace(/%20/g,\"+\")}});var m={},n,d=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]];function t(F,E){var G={};o.each(d.concat.apply([],d.slice(0,E)),function(){G[this]=F});return G}o.fn.extend({show:function(J,L){if(J){return this.animate(t(\"show\",3),J,L)}else{for(var H=0,F=this.length;H<F;H++){var E=o.data(this[H],\"olddisplay\");this[H].style.display=E||\"\";if(o.css(this[H],\"display\")===\"none\"){var G=this[H].tagName,K;if(m[G]){K=m[G]}else{var I=o(\"<\"+G+\" />\").appendTo(\"body\");K=I.css(\"display\");if(K===\"none\"){K=\"block\"}I.remove();m[G]=K}o.data(this[H],\"olddisplay\",K)}}for(var H=0,F=this.length;H<F;H++){this[H].style.display=o.data(this[H],\"olddisplay\")||\"\"}return this}},hide:function(H,I){if(H){return this.animate(t(\"hide\",3),H,I)}else{for(var G=0,F=this.length;G<F;G++){var E=o.data(this[G],\"olddisplay\");if(!E&&E!==\"none\"){o.data(this[G],\"olddisplay\",o.css(this[G],\"display\"))}}for(var G=0,F=this.length;G<F;G++){this[G].style.display=\"none\"}return this}},_toggle:o.fn.toggle,toggle:function(G,F){var E=typeof G===\"boolean\";return o.isFunction(G)&&o.isFunction(F)?this._toggle.apply(this,arguments):G==null||E?this.each(function(){var H=E?G:o(this).is(\":hidden\");o(this)[H?\"show\":\"hide\"]()}):this.animate(t(\"toggle\",3),G,F)},fadeTo:function(E,G,F){return this.animate({opacity:G},E,F)},animate:function(I,F,H,G){var E=o.speed(F,H,G);return this[E.queue===false?\"each\":\"queue\"](function(){var K=o.extend({},E),M,L=this.nodeType==1&&o(this).is(\":hidden\"),J=this;for(M in I){if(I[M]==\"hide\"&&L||I[M]==\"show\"&&!L){return K.complete.call(this)}if((M==\"height\"||M==\"width\")&&this.style){K.display=o.css(this,\"display\");K.overflow=this.style.overflow}}if(K.overflow!=null){this.style.overflow=\"hidden\"}K.curAnim=o.extend({},I);o.each(I,function(O,S){var R=new o.fx(J,K,O);if(/toggle|show|hide/.test(S)){R[S==\"toggle\"?L?\"show\":\"hide\":S](I)}else{var Q=S.toString().match(/^([+-]=)?([\\d+-.]+)(.*)$/),T=R.cur(true)||0;if(Q){var N=parseFloat(Q[2]),P=Q[3]||\"px\";if(P!=\"px\"){J.style[O]=(N||1)+P;T=((N||1)/R.cur(true))*T;J.style[O]=T+P}if(Q[1]){N=((Q[1]==\"-=\"?-1:1)*N)+T}R.custom(T,N,P)}else{R.custom(T,S,\"\")}}});return true})},stop:function(F,E){var G=o.timers;if(F){this.queue([])}this.each(function(){for(var H=G.length-1;H>=0;H--){if(G[H].elem==this){if(E){G[H](true)}G.splice(H,1)}}});if(!E){this.dequeue()}return this}});o.each({slideDown:t(\"show\",1),slideUp:t(\"hide\",1),slideToggle:t(\"toggle\",1),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"}},function(E,F){o.fn[E]=function(G,H){return this.animate(F,G,H)}});o.extend({speed:function(G,H,F){var E=typeof G===\"object\"?G:{complete:F||!F&&H||o.isFunction(G)&&G,duration:G,easing:F&&H||H&&!o.isFunction(H)&&H};E.duration=o.fx.off?0:typeof E.duration===\"number\"?E.duration:o.fx.speeds[E.duration]||o.fx.speeds._default;E.old=E.complete;E.complete=function(){if(E.queue!==false){o(this).dequeue()}if(o.isFunction(E.old)){E.old.call(this)}};return E},easing:{linear:function(G,H,E,F){return E+F*G},swing:function(G,H,E,F){return((-Math.cos(G*Math.PI)/2)+0.5)*F+E}},timers:[],fx:function(F,E,G){this.options=E;this.elem=F;this.prop=G;if(!E.orig){E.orig={}}}});o.fx.prototype={update:function(){if(this.options.step){this.options.step.call(this.elem,this.now,this)}(o.fx.step[this.prop]||o.fx.step._default)(this);if((this.prop==\"height\"||this.prop==\"width\")&&this.elem.style){this.elem.style.display=\"block\"}},cur:function(F){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null)){return this.elem[this.prop]}var E=parseFloat(o.css(this.elem,this.prop,F));return E&&E>-10000?E:parseFloat(o.curCSS(this.elem,this.prop))||0},custom:function(I,H,G){this.startTime=e();this.start=I;this.end=H;this.unit=G||this.unit||\"px\";this.now=this.start;this.pos=this.state=0;var E=this;function F(J){return E.step(J)}F.elem=this.elem;if(F()&&o.timers.push(F)&&!n){n=setInterval(function(){var K=o.timers;for(var J=0;J<K.length;J++){if(!K[J]()){K.splice(J--,1)}}if(!K.length){clearInterval(n);n=g}},13)}},show:function(){this.options.orig[this.prop]=o.attr(this.elem.style,this.prop);this.options.show=true;this.custom(this.prop==\"width\"||this.prop==\"height\"?1:0,this.cur());o(this.elem).show()},hide:function(){this.options.orig[this.prop]=o.attr(this.elem.style,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(H){var G=e();if(H||G>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;var E=true;for(var F in this.options.curAnim){if(this.options.curAnim[F]!==true){E=false}}if(E){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;this.elem.style.display=this.options.display;if(o.css(this.elem,\"display\")==\"none\"){this.elem.style.display=\"block\"}}if(this.options.hide){o(this.elem).hide()}if(this.options.hide||this.options.show){for(var I in this.options.curAnim){o.attr(this.elem.style,I,this.options.orig[I])}}this.options.complete.call(this.elem)}return false}else{var J=G-this.startTime;this.state=J/this.options.duration;this.pos=o.easing[this.options.easing||(o.easing.swing?\"swing\":\"linear\")](this.state,J,0,1,this.options.duration);this.now=this.start+((this.end-this.start)*this.pos);this.update()}return true}};o.extend(o.fx,{speeds:{slow:600,fast:200,_default:400},step:{opacity:function(E){o.attr(E.elem.style,\"opacity\",E.now)},_default:function(E){if(E.elem.style&&E.elem.style[E.prop]!=null){E.elem.style[E.prop]=E.now+E.unit}else{E.elem[E.prop]=E.now}}}});if(document.documentElement.getBoundingClientRect){o.fn.offset=function(){if(!this[0]){return{top:0,left:0}}if(this[0]===this[0].ownerDocument.body){return o.offset.bodyOffset(this[0])}var G=this[0].getBoundingClientRect(),J=this[0].ownerDocument,F=J.body,E=J.documentElement,L=E.clientTop||F.clientTop||0,K=E.clientLeft||F.clientLeft||0,I=G.top+(self.pageYOffset||o.boxModel&&E.scrollTop||F.scrollTop)-L,H=G.left+(self.pageXOffset||o.boxModel&&E.scrollLeft||F.scrollLeft)-K;return{top:I,left:H}}}else{o.fn.offset=function(){if(!this[0]){return{top:0,left:0}}if(this[0]===this[0].ownerDocument.body){return o.offset.bodyOffset(this[0])}o.offset.initialized||o.offset.initialize();var J=this[0],G=J.offsetParent,F=J,O=J.ownerDocument,M,H=O.documentElement,K=O.body,L=O.defaultView,E=L.getComputedStyle(J,null),N=J.offsetTop,I=J.offsetLeft;while((J=J.parentNode)&&J!==K&&J!==H){M=L.getComputedStyle(J,null);N-=J.scrollTop,I-=J.scrollLeft;if(J===G){N+=J.offsetTop,I+=J.offsetLeft;if(o.offset.doesNotAddBorder&&!(o.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(J.tagName))){N+=parseInt(M.borderTopWidth,10)||0,I+=parseInt(M.borderLeftWidth,10)||0}F=G,G=J.offsetParent}if(o.offset.subtractsBorderForOverflowNotVisible&&M.overflow!==\"visible\"){N+=parseInt(M.borderTopWidth,10)||0,I+=parseInt(M.borderLeftWidth,10)||0}E=M}if(E.position===\"relative\"||E.position===\"static\"){N+=K.offsetTop,I+=K.offsetLeft}if(E.position===\"fixed\"){N+=Math.max(H.scrollTop,K.scrollTop),I+=Math.max(H.scrollLeft,K.scrollLeft)}return{top:N,left:I}}}o.offset={initialize:function(){if(this.initialized){return}var L=document.body,F=document.createElement(\"div\"),H,G,N,I,M,E,J=L.style.marginTop,K='<div style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"><div></div></div><table style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\" cellpadding=\"0\" cellspacing=\"0\"><tr><td></td></tr></table>';M={position:\"absolute\",top:0,left:0,margin:0,border:0,width:\"1px\",height:\"1px\",visibility:\"hidden\"};for(E in M){F.style[E]=M[E]}F.innerHTML=K;L.insertBefore(F,L.firstChild);H=F.firstChild,G=H.firstChild,I=H.nextSibling.firstChild.firstChild;this.doesNotAddBorder=(G.offsetTop!==5);this.doesAddBorderForTableAndCells=(I.offsetTop===5);H.style.overflow=\"hidden\",H.style.position=\"relative\";this.subtractsBorderForOverflowNotVisible=(G.offsetTop===-5);L.style.marginTop=\"1px\";this.doesNotIncludeMarginInBodyOffset=(L.offsetTop===0);L.style.marginTop=J;L.removeChild(F);this.initialized=true},bodyOffset:function(E){o.offset.initialized||o.offset.initialize();var G=E.offsetTop,F=E.offsetLeft;if(o.offset.doesNotIncludeMarginInBodyOffset){G+=parseInt(o.curCSS(E,\"marginTop\",true),10)||0,F+=parseInt(o.curCSS(E,\"marginLeft\",true),10)||0}return{top:G,left:F}}};o.fn.extend({position:function(){var I=0,H=0,F;if(this[0]){var G=this.offsetParent(),J=this.offset(),E=/^body|html$/i.test(G[0].tagName)?{top:0,left:0}:G.offset();J.top-=j(this,\"marginTop\");J.left-=j(this,\"marginLeft\");E.top+=j(G,\"borderTopWidth\");E.left+=j(G,\"borderLeftWidth\");F={top:J.top-E.top,left:J.left-E.left}}return F},offsetParent:function(){var E=this[0].offsetParent||document.body;while(E&&(!/^body|html$/i.test(E.tagName)&&o.css(E,\"position\")==\"static\")){E=E.offsetParent}return o(E)}});o.each([\"Left\",\"Top\"],function(F,E){var G=\"scroll\"+E;o.fn[G]=function(H){if(!this[0]){return null}return H!==g?this.each(function(){this==l||this==document?l.scrollTo(!F?H:o(l).scrollLeft(),F?H:o(l).scrollTop()):this[G]=H}):this[0]==l||this[0]==document?self[F?\"pageYOffset\":\"pageXOffset\"]||o.boxModel&&document.documentElement[G]||document.body[G]:this[0][G]}});o.each([\"Height\",\"Width\"],function(I,G){var E=I?\"Left\":\"Top\",H=I?\"Right\":\"Bottom\",F=G.toLowerCase();o.fn[\"inner\"+G]=function(){return this[0]?o.css(this[0],F,false,\"padding\"):null};o.fn[\"outer\"+G]=function(K){return this[0]?o.css(this[0],F,false,K?\"margin\":\"border\"):null};var J=G.toLowerCase();o.fn[J]=function(K){return this[0]==l?document.compatMode==\"CSS1Compat\"&&document.documentElement[\"client\"+G]||document.body[\"client\"+G]:this[0]==document?Math.max(document.documentElement[\"client\"+G],document.body[\"scroll\"+G],document.documentElement[\"scroll\"+G],document.body[\"offset\"+G],document.documentElement[\"offset\"+G]):K===g?(this.length?o.css(this[0],J):null):this.css(J,typeof K===\"string\"?K:K+\"px\")}})})();","format":"text/ecmascript"},"/lib/qed/demo.rb":{"!":"script","path":"lib/qed/demo.rb","name":"demo.rb","mtime":"2011-11-18 11:59:19 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/demo.rb","language":"text/x-ruby"},"/lib/qed/cli/qed.rb":{"!":"script","path":"lib/qed/cli/qed.rb","name":"qed.rb","mtime":"2011-11-16 18:56:41 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/cli/qed.rb","language":"text/x-ruby"},"/lib/qed/cli/qedoc.rb":{"!":"script","path":"lib/qed/cli/qedoc.rb","name":"qedoc.rb","mtime":"2011-11-16 18:32:47 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/cli/qedoc.rb","language":"text/x-ruby"},"/lib/qed/cli.rb":{"!":"script","path":"lib/qed/cli.rb","name":"cli.rb","mtime":"2011-11-16 18:56:41 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/cli.rb","language":"text/x-ruby"},"/lib/qed/parser.rb":{"!":"script","path":"lib/qed/parser.rb","name":"parser.rb","mtime":"2011-11-18 11:07:14 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/parser.rb","language":"text/x-ruby"},"/lib/qed/settings.rb":{"!":"script","path":"lib/qed/settings.rb","name":"settings.rb","mtime":"2011-11-18 12:26:44 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/settings.rb","language":"text/x-ruby"},"/lib/qed/core_ext.rb":{"!":"script","path":"lib/qed/core_ext.rb","name":"core_ext.rb","mtime":"2010-11-03 11:35:43 -0400","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/core_ext.rb","language":"text/x-ruby"},"/lib/qed/session.rb":{"!":"script","path":"lib/qed/session.rb","name":"session.rb","mtime":"2011-11-18 15:15:08 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/session.rb","language":"text/x-ruby"},"/lib/qed/step.rb":{"!":"script","path":"lib/qed/step.rb","name":"step.rb","mtime":"2011-11-19 12:46:56 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/step.rb","language":"text/x-ruby"},"/lib/qed/reporter/verbatim.rb":{"!":"script","path":"lib/qed/reporter/verbatim.rb","name":"verbatim.rb","mtime":"2011-11-19 13:34:47 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/verbatim.rb","language":"text/x-ruby"},"/lib/qed/reporter/tapy.rb":{"!":"script","path":"lib/qed/reporter/tapy.rb","name":"tapy.rb","mtime":"2011-11-18 20:11:13 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/tapy.rb","language":"text/x-ruby"},"/lib/qed/reporter/html.rb":{"!":"script","path":"lib/qed/reporter/html.rb","name":"html.rb","mtime":"2011-11-19 11:22:43 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/html.rb","language":"text/x-ruby"},"/lib/qed/reporter/dotprogress.rb":{"!":"script","path":"lib/qed/reporter/dotprogress.rb","name":"dotprogress.rb","mtime":"2011-11-16 00:07:12 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/dotprogress.rb","language":"text/x-ruby"},"/lib/qed/reporter/linear.rb":{"!":"script","path":"lib/qed/reporter/linear.rb","name":"linear.rb","mtime":"2011-11-18 21:18:33 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/linear.rb","language":"text/x-ruby"},"/lib/qed/reporter/abstract.rb":{"!":"script","path":"lib/qed/reporter/abstract.rb","name":"abstract.rb","mtime":"2011-11-18 20:45:17 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/abstract.rb","language":"text/x-ruby"},"/lib/qed/reporter/bullet.rb":{"!":"script","path":"lib/qed/reporter/bullet.rb","name":"bullet.rb","mtime":"2011-11-16 00:19:27 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/reporter/bullet.rb","language":"text/x-ruby"},"/lib/qed/scope.rb":{"!":"script","path":"lib/qed/scope.rb","name":"scope.rb","mtime":"2011-11-18 11:50:48 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/scope.rb","language":"text/x-ruby"},"/lib/qed/qparser.rb":{"!":"script","path":"lib/qed/qparser.rb","name":"qparser.rb","mtime":"2011-11-18 10:04:11 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/qparser.rb","language":"text/x-ruby"},"/lib/qed/evaluator.rb":{"!":"script","path":"lib/qed/evaluator.rb","name":"evaluator.rb","mtime":"2011-11-19 10:23:03 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/evaluator.rb","language":"text/x-ruby"},"/lib/qed/document.rb":{"!":"script","path":"lib/qed/document.rb","name":"document.rb","mtime":"2011-11-18 15:04:05 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/document.rb","language":"text/x-ruby"},"/lib/qed/helpers/shell_session.rb":{"!":"script","path":"lib/qed/helpers/shell_session.rb","name":"shell_session.rb","mtime":"2010-07-17 07:46:44 -0400","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/helpers/shell_session.rb","language":"text/x-ruby"},"/lib/qed/helpers/file_fixtures.rb":{"!":"script","path":"lib/qed/helpers/file_fixtures.rb","name":"file_fixtures.rb","mtime":"2010-11-03 13:29:31 -0400","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/helpers/file_fixtures.rb","language":"text/x-ruby"},"/lib/qed/applique.rb":{"!":"script","path":"lib/qed/applique.rb","name":"applique.rb","mtime":"2011-11-18 12:09:44 -0500","source_url":"http://raw.github.com/rubyworks/qed/master/lib/qed/applique.rb","language":"text/x-ruby"}}
